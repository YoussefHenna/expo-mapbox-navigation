// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name MapboxNavigationCore
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFAudio
import AVFoundation
import AVKit
import CarPlay
import Combine
import CommonCrypto
import CoreGraphics
import CoreLocation
import Dispatch
import Foundation
import Foundation/*.Bundle*/
import Foundation/*.ProcessInfo*/
import Foundation/*.URL*/
import MapboxCommon_Private.MBXLog_Internal
import MapboxCommon
import MapboxCommon_Private
import MapboxDirections
import MapboxMaps
import MapboxNavigationNative
import MapboxNavigationNative/*.NavigationStatus*/
import MapboxNavigationNative/*.UpcomingRouteAlert*/
import MapboxNavigationNative_Private
import Network
import OSLog
import Swift
import SwiftUI/*.ColorScheme*/
import Turf
import UIKit
import _Concurrency
import _MapboxNavigationHelpers
import _StringProcessing
import _SwiftConcurrencyShims
public struct ApiConfiguration : Swift.Sendable, Swift.Equatable {
  public static var `default`: MapboxNavigationCore.ApiConfiguration {
    get
  }
  public let accessToken: Swift.String
  public init(accessToken: Swift.String)
  public static func == (a: MapboxNavigationCore.ApiConfiguration, b: MapboxNavigationCore.ApiConfiguration) -> Swift.Bool
}
public struct SkuTokenProvider : Swift.Sendable {
  public let skuToken: @Sendable () -> Swift.String?
  public init(skuToken: @escaping @Sendable () -> Swift.String?)
}
extension Foundation.NSNotification.Name {
  @_documentation(visibility: internal) public static let navigationDidSwitchToFallbackVersion: Foundation.Notification.Name
  @_documentation(visibility: internal) public static let navigationDidSwitchToTargetVersion: Foundation.Notification.Name
}
extension Foundation.NSNotification.Name {
  public static let electronicHorizonDidUpdatePosition: Foundation.Notification.Name
  public static let electronicHorizonDidEnterRoadObject: Foundation.Notification.Name
  public static let electronicHorizonDidExitRoadObject: Foundation.Notification.Name
  public static let electronicHorizonDidPassRoadObject: Foundation.Notification.Name
}
extension MapboxNavigationCore.RoadGraph {
  public struct NotificationUserInfoKey : Swift.Hashable, Swift.Equatable, Swift.RawRepresentable, Swift.Sendable {
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String
    public init(rawValue: Swift.String)
    public static let positionKey: MapboxNavigationCore.RoadGraph.NotificationUserInfoKey
    public static let treeKey: MapboxNavigationCore.RoadGraph.NotificationUserInfoKey
    public static let updatesMostProbablePathKey: MapboxNavigationCore.RoadGraph.NotificationUserInfoKey
    public static let distancesByRoadObjectKey: MapboxNavigationCore.RoadGraph.NotificationUserInfoKey
    public static let roadObjectIdentifierKey: MapboxNavigationCore.RoadGraph.NotificationUserInfoKey
    public static let didTransitionAtEndpointKey: MapboxNavigationCore.RoadGraph.NotificationUserInfoKey
  }
}
@available(*, deprecated, message: "This extension is no longer supported.")
extension AVFAudio.AVAudioSession {
  public func tryDuckAudio() -> (any Swift.Error)?
  public func tryUnduckAudio() -> (any Swift.Error)?
}
extension Foundation.Bundle {
  public var backgroundModes: Swift.Set<Swift.String> {
    get
  }
  public static let mapboxNavigationUXCore: Foundation.Bundle
  public func image(named: Swift.String) -> UIKit.UIImage?
}
public typealias CongestionRange = Swift.Range<MapboxDirections.NumericCongestionLevel>
public struct CongestionRangesConfiguration : Swift.Equatable, Swift.Sendable {
  public var low: MapboxNavigationCore.CongestionRange
  public var moderate: MapboxNavigationCore.CongestionRange
  public var heavy: MapboxNavigationCore.CongestionRange
  public var severe: MapboxNavigationCore.CongestionRange
  public init(low: MapboxNavigationCore.CongestionRange, moderate: MapboxNavigationCore.CongestionRange, heavy: MapboxNavigationCore.CongestionRange, severe: MapboxNavigationCore.CongestionRange)
  public static var `default`: MapboxNavigationCore.CongestionRangesConfiguration {
    get
  }
  public static func == (a: MapboxNavigationCore.CongestionRangesConfiguration, b: MapboxNavigationCore.CongestionRangesConfiguration) -> Swift.Bool
}
extension MapboxDirections.CongestionLevel {
  public var asCPTimeRemainingColor: CarPlay.CPTimeRemainingColor {
    get
  }
}
extension MapboxDirections.RouteLeg {
  public func resolveCongestionLevels(using configuration: MapboxNavigationCore.CongestionRangesConfiguration) -> [MapboxNavigationCore.CongestionLevel]?
}
extension Foundation.Locale {
  public static var preferredLocalLanguageCountryCode: Swift.String {
    get
  }
  public static var nationalizedCurrent: Foundation.Locale {
    get
  }
}
extension MapboxDirections.MapboxStreetsRoadClass {
  public var isRamp: Swift.Bool {
    get
  }
}
extension MapboxDirections.MeasurementSystem {
  public init(_ lengthUnit: Foundation.LengthFormatter.Unit)
}
extension Turf.LineString : @unchecked Swift.Sendable {
}
extension MapboxMaps.Puck3DConfiguration : @unchecked Swift.Sendable {
}
extension MapboxMaps.Puck2DConfiguration : @unchecked Swift.Sendable {
}
extension MapboxDirections.RouteLeg {
  public var shape: Turf.LineString {
    get
  }
  public var streetsRoadClasses: [MapboxDirections.MapboxStreetsRoadClass?] {
    get
  }
  public var roadClasses: [MapboxNavigationCore.RoadClasses?] {
    get
  }
}
extension Swift.Array {
  public func filterKeepingFirstAndLast(_ isIncluded: (Element) throws -> Swift.Bool) rethrows -> [Element]
  public func splitExceptAtStartAndEnd(maxSplits: Swift.Int = .max, omittingEmptySubsequences: Swift.Bool = true, whereSeparator isSeparator: (Element) throws -> Swift.Bool) rethrows -> [Swift.ArraySlice<Element>]
}
extension Foundation.NSAttributedString {
  public func pronounced(_ pronunciation: Swift.String) -> Foundation.NSAttributedString
}
extension Swift.String {
  public func minimumEditDistance(to word: Swift.String) -> Swift.Int
}
public enum ActiveNavigationFeedbackType : MapboxNavigationCore.FeedbackType {
  case closure
  case poorRoute
  case wrongSpeedLimit
  case badRoute
  case illegalTurn
  case roadClosed
  case incorrectLaneGuidance
  case other
  case arrival(rating: Swift.Int)
  case falsePositiveTraffic
  case falseNegativeTraffic
  case missingConstruction
  case missingSpeedLimit
  public var typeKey: Swift.String {
    get
  }
  public var subtypeKey: Swift.String? {
    get
  }
}
public enum FeedbackSource : Swift.Int, Swift.CustomStringConvertible, Swift.Sendable {
  case user
  case reroute
  case unknown
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class NavigationEventsManager : Swift.Sendable {
  final public var userInfo: [Swift.String : Swift.String?]? {
    get
    set
  }
  final public func createFeedback(screenshotOption: MapboxNavigationCore.FeedbackScreenshotOption = .automatic) async -> MapboxNavigationCore.FeedbackEvent?
  final public func sendActiveNavigationFeedback(_ feedback: MapboxNavigationCore.FeedbackEvent, type: MapboxNavigationCore.ActiveNavigationFeedbackType, description: Swift.String? = nil)
  final public func sendPassiveNavigationFeedback(_ feedback: MapboxNavigationCore.FeedbackEvent, type: MapboxNavigationCore.PassiveNavigationFeedbackType, description: Swift.String? = nil)
  final public func sendActiveNavigationFeedback(_ feedback: MapboxNavigationCore.FeedbackEvent, type: MapboxNavigationCore.ActiveNavigationFeedbackType, description: Swift.String?, source: MapboxNavigationCore.FeedbackSource) async -> MapboxNavigationCore.UserFeedback?
  final public func sendNavigationFeedback(_ feedback: MapboxNavigationCore.FeedbackEvent, type: any MapboxNavigationCore.FeedbackType, description: Swift.String?, source: MapboxNavigationCore.FeedbackSource) async throws -> MapboxNavigationCore.UserFeedback?
  final public func sendPassiveNavigationFeedback(_ feedback: MapboxNavigationCore.FeedbackEvent, type: MapboxNavigationCore.PassiveNavigationFeedbackType, description: Swift.String?, source: MapboxNavigationCore.FeedbackSource) async -> MapboxNavigationCore.UserFeedback?
  final public func sendCarPlayConnectEvent()
  final public func sendCarPlayDisconnectEvent()
  @objc deinit
}
public struct FeedbackEvent : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public let metadata: MapboxNavigationCore.FeedbackMetadata
  public var contents: [Swift.String : Any] {
    get
  }
  public static func == (a: MapboxNavigationCore.FeedbackEvent, b: MapboxNavigationCore.FeedbackEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct FeedbackMetadata : Swift.Sendable, Swift.Equatable {
  public static func == (lhs: MapboxNavigationCore.FeedbackMetadata, rhs: MapboxNavigationCore.FeedbackMetadata) -> Swift.Bool
  public let screenshot: Swift.String?
  public var contents: [Swift.String : Any] {
    get
  }
}
extension MapboxNavigationCore.FeedbackMetadata : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension MapboxNavigationNative.UserFeedbackMetadata : @unchecked Swift.Sendable {
}
extension MapboxNavigationNative.UserFeedbackMetadata : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum FeedbackScreenshotOption : Swift.Sendable {
  case automatic
  case custom(UIKit.UIImage)
}
public protocol FeedbackType : Swift.Sendable {
  var typeKey: Swift.String { get }
  var subtypeKey: Swift.String? { get }
}
public enum PassiveNavigationFeedbackType : MapboxNavigationCore.FeedbackType {
  case poorGPS
  case incorrectMapData
  case accident
  case camera
  case traffic
  case wrongSpeedLimit
  case other
  public var typeKey: Swift.String {
    get
  }
  public var subtypeKey: Swift.String? {
    get
  }
  public static func == (a: MapboxNavigationCore.PassiveNavigationFeedbackType, b: MapboxNavigationCore.PassiveNavigationFeedbackType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_documentation(visibility: internal) public enum SearchFeedbackType : MapboxNavigationCore.FeedbackType {
  case incorrectName
  case incorrectAddress
  case incorrectLocation
  case phoneNumber
  case resultRank
  case missingResult
  case other
  public var typeKey: Swift.String {
    get
  }
  public var subtypeKey: Swift.String? {
    get
  }
  public static func == (a: MapboxNavigationCore.SearchFeedbackType, b: MapboxNavigationCore.SearchFeedbackType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public actor CopilotService {
  public var mapboxCopilot: MapboxNavigationCore.MapboxCopilot? {
    get
  }
  public func setActive(_ isActive: Swift.Bool)
  public var isActive: Swift.Bool {
    get
  }
  public func setDelegate(_ delegate: any MapboxNavigationCore.MapboxCopilotDelegate)
  weak public var delegate: (any MapboxNavigationCore.MapboxCopilotDelegate)? {
    get
  }
  public init(accessToken: Swift.String, navNativeVersion: Swift.String, historyRecording: any MapboxNavigationCore.HistoryRecording, isActive: Swift.Bool = true, log: (@Sendable (Swift.String) -> Swift.Void)? = nil)
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
public protocol NavigationHistoryEvent {
  associatedtype Payload : Swift.Encodable
  var eventType: Swift.String { get }
  var payload: Self.Payload { get }
}
public enum NavigationHistoryEvents {
}
extension MapboxNavigationCore.NavigationHistoryEvents {
  public struct Coordinate : Swift.Encodable, Swift.Sendable {
    public init(_ coordinate: CoreLocation.CLLocationCoordinate2D)
    public func encode(to encoder: any Swift.Encoder) throws
  }
  public struct RoutablePoint : Swift.Encodable, Swift.Sendable {
    public var coordinates: MapboxNavigationCore.NavigationHistoryEvents.Coordinate
    public init(coordinates: MapboxNavigationCore.NavigationHistoryEvents.Coordinate)
    public func encode(to encoder: any Swift.Encoder) throws
  }
  public struct SearchResultUsed : Swift.Sendable {
    public enum Provider : Swift.String, Swift.Encodable, Swift.Sendable {
      case mapbox
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public struct Payload : Swift.Encodable, Swift.Sendable {
      public var provider: MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed.Provider
      public var id: Swift.String
      public var name: Swift.String
      public var address: Swift.String
      public var coordinate: MapboxNavigationCore.NavigationHistoryEvents.Coordinate
      public var routablePoint: [MapboxNavigationCore.NavigationHistoryEvents.RoutablePoint]?
      public init(provider: MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed.Provider, id: Swift.String, name: Swift.String, address: Swift.String, coordinate: MapboxNavigationCore.NavigationHistoryEvents.Coordinate, routablePoint: [MapboxNavigationCore.NavigationHistoryEvents.RoutablePoint]?)
      public func encode(to encoder: any Swift.Encoder) throws
    }
    public let eventType: Swift.String
    public var payload: MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed.Payload
    public init(payload: MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed.Payload)
  }
}
extension MapboxNavigationCore.NavigationHistoryEvents {
  public struct SearchResults : Swift.Sendable {
    public struct SearchResult : Swift.Encodable, Swift.Sendable {
      public var id: Swift.String
      public var name: Swift.String
      public var address: Swift.String
      public var coordinate: MapboxNavigationCore.NavigationHistoryEvents.Coordinate?
      public var routablePoint: [MapboxNavigationCore.NavigationHistoryEvents.RoutablePoint]?
      public init(id: Swift.String, name: Swift.String, address: Swift.String, coordinate: MapboxNavigationCore.NavigationHistoryEvents.Coordinate? = nil, routablePoint: [MapboxNavigationCore.NavigationHistoryEvents.RoutablePoint]? = nil)
      public func encode(to encoder: any Swift.Encoder) throws
    }
    public struct Payload : Swift.Encodable, Swift.Sendable {
      public var provider: MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed.Provider
      public var request: Swift.String
      public var response: Swift.String?
      public var error: Swift.String?
      public var searchQuery: Swift.String
      public var results: [MapboxNavigationCore.NavigationHistoryEvents.SearchResults.SearchResult]?
      public init(provider: MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed.Provider, request: Swift.String, response: Swift.String? = nil, error: Swift.String? = nil, searchQuery: Swift.String, results: [MapboxNavigationCore.NavigationHistoryEvents.SearchResults.SearchResult]? = nil)
      public func encode(to encoder: any Swift.Encoder) throws
    }
    public let eventType: Swift.String
    public var payload: MapboxNavigationCore.NavigationHistoryEvents.SearchResults.Payload
    public init(payload: MapboxNavigationCore.NavigationHistoryEvents.SearchResults.Payload)
  }
}
@_hasMissingDesignatedInitializers public actor MapboxCopilot {
  public typealias Log = @Sendable (Swift.String) -> Swift.Void
  public struct Options : Swift.Sendable {
    public init(accessToken: Swift.String, userId: Swift.String, navNativeVersion: Swift.String, sdkVersion: Swift.String, sdkName: Swift.String, packageName: Swift.String, log: (@Sendable (Swift.String) -> Swift.Void)? = nil)
  }
  public var currentSession: MapboxNavigationCore.NavigationSession? {
    get
  }
  public func setDelegate(_ delegate: (any MapboxNavigationCore.MapboxCopilotDelegate)?)
  weak public var delegate: (any MapboxNavigationCore.MapboxCopilotDelegate)? {
    get
  }
  @_Concurrency.MainActor public convenience init(options: MapboxNavigationCore.MapboxCopilot.Options, historyProvider: any MapboxNavigationCore.NavigationHistoryProviderProtocol)
  @available(*, deprecated, message: "Use startActiveGuidanceSessionAsync(requestIdentifier:route:searchResultUsed:) instead. Using the deprecated\nmethod may lead to losing events in the recorded history files.")
  @discardableResult
  public func startActiveGuidanceSession(requestIdentifier: Swift.String?, route: any Swift.Encodable, searchResultUsed: MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed? = nil) throws -> Swift.String
  @available(*, deprecated, message: "Use startFreeDriveSessionAsync() instead. Using the deprecated method may lead to losing events in the recorded\nhistory files.")
  @discardableResult
  public func startFreeDriveSession() throws -> Swift.String
  @available(*, deprecated, message: "Use completeNavigationSessionAsync() instead. Using the deprecated method may lead to losing events in the\nrecorded history files.")
  public func completeNavigationSession() throws
  @discardableResult
  public func startActiveGuidanceSessionAsync(requestIdentifier: Swift.String?, route: any Swift.Encodable, searchResultUsed: MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed? = nil) async throws -> Swift.String
  @discardableResult
  public func startFreeDriveSessionAsync() async throws -> Swift.String
  public func arrive()
  public func completeNavigationSessionAsync() async throws
  public func reportSearchResults(_ event: MapboxNavigationCore.NavigationHistoryEvents.SearchResults) throws
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
public protocol MapboxCopilotDelegate : AnyObject, Swift.Sendable {
  func copilot(_ copilot: MapboxNavigationCore.MapboxCopilot, didFinishRecording session: MapboxNavigationCore.NavigationSession)
  func copilot(_ copilot: MapboxNavigationCore.MapboxCopilot, didUploadHistoryFileForSession session: MapboxNavigationCore.NavigationSession)
  func copilot(_ copilot: MapboxNavigationCore.MapboxCopilot, didEncounterError error: MapboxNavigationCore.CopilotError)
}
public struct CopilotError : Swift.Error {
}
public enum NavigationHistoryFormat : Swift.Codable, Swift.Equatable, Swift.Sendable {
  case json
  case protobuf
  case unknown(Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (lhs: MapboxNavigationCore.NavigationHistoryFormat, rhs: MapboxNavigationCore.NavigationHistoryFormat) -> Swift.Bool
}
public enum NavigationHistoryProviderError : Swift.Error, Swift.Sendable {
  case noHistory
  case notFound(_: Swift.String)
}
public protocol NavigationHistoryProviderProtocol : AnyObject {
  typealias Filepath = Swift.String
  typealias DumpResult = Swift.Result<(Self.Filepath, MapboxNavigationCore.NavigationHistoryFormat), MapboxNavigationCore.NavigationHistoryProviderError>
  @_Concurrency.MainActor func startRecording()
  func pushEvent<T>(event: T) throws where T : MapboxNavigationCore.NavigationHistoryEvent
  @_Concurrency.MainActor func dumpHistory(_ completion: @escaping @Sendable (Self.DumpResult) -> Swift.Void)
}
public struct NavigationSession : Swift.Codable, Swift.Equatable, @unchecked Swift.Sendable {
  public enum SessionType : Swift.String, Swift.Codable {
    case activeGuidance
    case freeDrive
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum State : Swift.String, Swift.Codable {
    case inProgress
    case local
    case uploading
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let id: Swift.String
  public let startedAt: Foundation.Date
  public let userId: Swift.String
  public var sessionType: MapboxNavigationCore.NavigationSession.SessionType {
    get
  }
  public var accessToken: Swift.String {
    get
  }
  public var state: MapboxNavigationCore.NavigationSession.State {
    get
  }
  public var routeId: Swift.String? {
    get
  }
  public var endedAt: Foundation.Date? {
    get
  }
  public var historyError: Swift.String? {
    get
  }
  public var appMode: Swift.String {
    get
  }
  public var appVersion: Swift.String {
    get
  }
  public var navigationSdkVersion: Swift.String {
    get
  }
  public var navigationNativeSdkVersion: Swift.String {
    get
  }
  public var tokenOwner: Swift.String? {
    get
  }
  public var appSessionId: Swift.String {
    get
  }
  public static func == (a: MapboxNavigationCore.NavigationSession, b: MapboxNavigationCore.NavigationSession) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol HistoryEvent : Swift.Equatable, Swift.Sendable {
  var timestamp: Foundation.TimeInterval { get }
}
public struct RouteAssignmentHistoryEvent : MapboxNavigationCore.HistoryEvent {
  public let timestamp: Foundation.TimeInterval
  public let navigationRoutes: MapboxNavigationCore.NavigationRoutes
  public static func == (a: MapboxNavigationCore.RouteAssignmentHistoryEvent, b: MapboxNavigationCore.RouteAssignmentHistoryEvent) -> Swift.Bool
}
public struct LocationUpdateHistoryEvent : MapboxNavigationCore.HistoryEvent {
  public let timestamp: Foundation.TimeInterval
  public let location: CoreLocation.CLLocation
  public static func == (a: MapboxNavigationCore.LocationUpdateHistoryEvent, b: MapboxNavigationCore.LocationUpdateHistoryEvent) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class UnknownHistoryEvent : MapboxNavigationCore.HistoryEvent, @unchecked Swift.Sendable {
  public static func == (lhs: MapboxNavigationCore.UnknownHistoryEvent, rhs: MapboxNavigationCore.UnknownHistoryEvent) -> Swift.Bool
  final public let timestamp: Foundation.TimeInterval
  @objc deinit
}
public struct UserPushedHistoryEvent : MapboxNavigationCore.HistoryEvent {
  public let timestamp: Foundation.TimeInterval
  public let type: Swift.String
  public let properties: Swift.String
  public static func == (a: MapboxNavigationCore.UserPushedHistoryEvent, b: MapboxNavigationCore.UserPushedHistoryEvent) -> Swift.Bool
}
public struct History {
  public var events: [any MapboxNavigationCore.HistoryEvent] {
    get
  }
  public var initialRoute: MapboxNavigationCore.NavigationRoutes? {
    get
  }
  public var rawLocations: [CoreLocation.CLLocation] {
    get
  }
}
public struct HistoryReader : _Concurrency.AsyncSequence, Swift.Sendable {
  public typealias Element = MapboxNavigationCore.HistoryEvent
  public struct ReadOptions : Swift.OptionSet, Swift.Sendable {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let omitUnknownEvents: MapboxNavigationCore.HistoryReader.ReadOptions
    public typealias ArrayLiteralElement = MapboxNavigationCore.HistoryReader.ReadOptions
    public typealias Element = MapboxNavigationCore.HistoryReader.ReadOptions
    public typealias RawValue = Swift.UInt
  }
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async -> (any MapboxNavigationCore.HistoryEvent)?
    public typealias Element = (any MapboxNavigationCore.HistoryEvent)
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #endif
  }
  public func makeAsyncIterator() -> MapboxNavigationCore.HistoryReader.AsyncIterator
  public init?(fileUrl: Foundation.URL, readOptions: MapboxNavigationCore.HistoryReader.ReadOptions? = nil)
  public init?(data: Foundation.Data, readOptions: MapboxNavigationCore.HistoryReader.ReadOptions? = nil)
  public func parse() async throws -> MapboxNavigationCore.History
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
}
public protocol HistoryRecording : Swift.Sendable {
  typealias HistoryFileWritingCompletionHandler = @Sendable (_ historyFileURL: Foundation.URL?) -> Swift.Void
  @_Concurrency.MainActor func startRecordingHistory()
  func pushHistoryEvent(type: Swift.String, jsonData: Foundation.Data?)
  @_Concurrency.MainActor func stopRecordingHistory(writingFileWith completionHandler: @escaping Self.HistoryFileWritingCompletionHandler)
}
extension MapboxNavigationCore.HistoryRecording {
  public func pushHistoryEvent(type: Swift.String, value: (some Encodable)?, encoder: Foundation.JSONEncoder? = nil) throws
  public func pushHistoryEvent(type: Swift.String, dictionary value: [Swift.String : Any?]?) throws
}
@_hasMissingDesignatedInitializers final public class HistoryReplayController : Swift.Sendable {
  weak final public var delegate: (any MapboxNavigationCore.HistoryReplayDelegate)? {
    get
    set
  }
  final public var speedMultiplier: Swift.Double {
    get
    set
  }
  final public var locations: Combine.AnyPublisher<CoreLocation.CLLocation, Swift.Never> {
    get
  }
  final public var isPaused: Swift.Bool {
    get
  }
  convenience public init(history: MapboxNavigationCore.History)
  convenience public init(historyReader: MapboxNavigationCore.HistoryReader)
  final public func seekTo(event: any MapboxNavigationCore.HistoryEvent) async -> Swift.Bool
  final public func seekTo(offset: Foundation.TimeInterval) async -> Swift.Bool
  final public func play()
  final public func pause()
  final public func push(location: CoreLocation.CLLocation)
  final public func push(events history: MapboxNavigationCore.History)
  final public func push(events historyReader: MapboxNavigationCore.HistoryReader)
  final public func clearEvents()
  final public func eventOffest(_ event: any MapboxNavigationCore.HistoryEvent) -> Foundation.TimeInterval?
  @objc deinit
}
public protocol HistoryReplayDelegate : AnyObject, Swift.Sendable {
  func historyReplayController(_ controller: MapboxNavigationCore.HistoryReplayController, didReplayEvent event: any MapboxNavigationCore.HistoryEvent)
  func historyReplayController(_ controller: MapboxNavigationCore.HistoryReplayController, wantsToSetRoutes navigationRoutes: MapboxNavigationCore.NavigationRoutes)
  func historyReplayControllerDidFinishReplay(_ controller: MapboxNavigationCore.HistoryReplayController)
}
extension MapboxNavigationCore.LocationClient {
  public static func historyReplayingValue(with controller: MapboxNavigationCore.HistoryReplayController) -> MapboxNavigationCore.LocationClient
}
@_hasMissingDesignatedInitializers final public class IdleTimerManager : Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class Cancellable : Swift.Sendable {
    @objc deinit
  }
  public static let shared: MapboxNavigationCore.IdleTimerManager
  final public func disableIdleTimer() -> MapboxNavigationCore.IdleTimerManager.Cancellable
  final public func disableIdleTimer(id: Swift.String)
  final public func enableIdleTimer(id: Swift.String)
  @objc deinit
}
public struct LocalizationManager {
  public static var customLocalizationBundle: Foundation.Bundle? {
    get
    set
  }
  public static func localizedString(_ key: Swift.String, tableName: Swift.String? = nil, defaultBundle: Foundation.Bundle, value: Swift.String, comment: Swift.String = "") -> Swift.String
}
@_Concurrency.MainActor public protocol CameraStateTransition : AnyObject {
  @_Concurrency.MainActor var mapView: MapboxMaps.MapView? { get }
  @_Concurrency.MainActor init(_ mapView: MapboxMaps.MapView)
  @_Concurrency.MainActor func transitionTo(_ cameraOptions: MapboxMaps.CameraOptions, completion: @escaping (() -> Swift.Void))
  @_Concurrency.MainActor func update(to cameraOptions: MapboxMaps.CameraOptions, state: MapboxNavigationCore.NavigationCameraState)
  @_Concurrency.MainActor func cancelPendingTransition()
}
public struct FollowingCameraOptions : Swift.Equatable, Swift.Sendable {
  public var defaultPitch: Swift.Double {
    get
    set
  }
  public var zoomRange: Swift.ClosedRange<Swift.Double> {
    get
    set
  }
  public var centerUpdatesAllowed: Swift.Bool
  public var zoomUpdatesAllowed: Swift.Bool
  public var bearingUpdatesAllowed: Swift.Bool
  public var pitchUpdatesAllowed: Swift.Bool
  public var paddingUpdatesAllowed: Swift.Bool
  public var intersectionDensity: MapboxNavigationCore.IntersectionDensity
  public var bearingSmoothing: MapboxNavigationCore.BearingSmoothing
  public var geometryFramingAfterManeuver: MapboxNavigationCore.GeometryFramingAfterManeuver
  public var pitchNearManeuver: MapboxNavigationCore.PitchNearManeuver
  public var followsLocationCourse: Swift.Bool
  public init()
  public static func == (lhs: MapboxNavigationCore.FollowingCameraOptions, rhs: MapboxNavigationCore.FollowingCameraOptions) -> Swift.Bool
}
public struct IntersectionDensity : Swift.Equatable, Swift.Sendable {
  public var enabled: Swift.Bool
  public var averageDistanceMultiplier: Swift.Double
  public var minimumDistanceBetweenIntersections: Swift.Double
  public init()
  public static func == (lhs: MapboxNavigationCore.IntersectionDensity, rhs: MapboxNavigationCore.IntersectionDensity) -> Swift.Bool
}
public struct BearingSmoothing : Swift.Equatable, Swift.Sendable {
  public var enabled: Swift.Bool
  public var maximumBearingSmoothingAngle: Swift.Double
  public init()
  public static func == (lhs: MapboxNavigationCore.BearingSmoothing, rhs: MapboxNavigationCore.BearingSmoothing) -> Swift.Bool
}
public struct GeometryFramingAfterManeuver : Swift.Equatable, Swift.Sendable {
  public var enabled: Swift.Bool
  public var distanceToCoalesceCompoundManeuvers: Swift.Double
  public var distanceToFrameAfterManeuver: Swift.Double
  public init()
  public static func == (lhs: MapboxNavigationCore.GeometryFramingAfterManeuver, rhs: MapboxNavigationCore.GeometryFramingAfterManeuver) -> Swift.Bool
}
public struct PitchNearManeuver : Swift.Equatable, Swift.Sendable {
  public var enabled: Swift.Bool
  public var triggerDistanceToManeuver: Swift.Double
  public init()
  public static func == (lhs: MapboxNavigationCore.PitchNearManeuver, rhs: MapboxNavigationCore.PitchNearManeuver) -> Swift.Bool
}
@_Concurrency.MainActor public class NavigationCamera {
  @_Concurrency.MainActor public var cameraStates: Combine.AnyPublisher<MapboxNavigationCore.NavigationCameraState, Swift.Never> {
    get
  }
  @_Concurrency.MainActor public var viewportPadding: UIKit.UIEdgeInsets {
    get
    set
  }
  @_Concurrency.MainActor required public init(_ mapView: MapboxMaps.MapView, location: Combine.AnyPublisher<CoreLocation.CLLocation, Swift.Never>, routeProgress: Combine.AnyPublisher<MapboxNavigationCore.RouteProgress?, Swift.Never>, heading: Combine.AnyPublisher<CoreLocation.CLHeading, Swift.Never>? = nil, navigationCameraType: MapboxNavigationCore.NavigationCameraType = .mobile, viewportDataSource: (any MapboxNavigationCore.ViewportDataSource)? = nil, cameraStateTransition: (any MapboxNavigationCore.CameraStateTransition)? = nil)
  @_Concurrency.MainActor public func update(cameraState: MapboxNavigationCore.NavigationCameraState)
  @_Concurrency.MainActor public func stop()
  @_Concurrency.MainActor public var viewportDataSource: any MapboxNavigationCore.ViewportDataSource {
    get
    set
  }
  @_Concurrency.MainActor public var currentCameraState: MapboxNavigationCore.NavigationCameraState {
    get
  }
  @_Concurrency.MainActor public var cameraStateTransition: any MapboxNavigationCore.CameraStateTransition
  @objc deinit
}
extension MapboxMaps.CameraOptions : @unchecked Swift.Sendable {
}
public struct NavigationCameraOptions : Swift.Equatable, Swift.Sendable {
  public var followingCamera: MapboxMaps.CameraOptions
  public var overviewCamera: MapboxMaps.CameraOptions
  public init(followingCamera: MapboxMaps.CameraOptions = .init(), overviewCamera: MapboxMaps.CameraOptions = .init())
  public static func == (a: MapboxNavigationCore.NavigationCameraOptions, b: MapboxNavigationCore.NavigationCameraOptions) -> Swift.Bool
}
public enum NavigationCameraState : Swift.Equatable, Swift.Sendable {
  case idle
  case following
  case overview
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxNavigationCore.NavigationCameraState, b: MapboxNavigationCore.NavigationCameraState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension MapboxNavigationCore.NavigationCameraState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_Concurrency.MainActor public class NavigationCameraStateTransition : MapboxNavigationCore.CameraStateTransition {
  @_Concurrency.MainActor weak public var mapView: MapboxMaps.MapView?
  @_Concurrency.MainActor required public init(_ mapView: MapboxMaps.MapView)
  @_Concurrency.MainActor public func transitionTo(_ cameraOptions: MapboxMaps.CameraOptions, completion: @escaping () -> Swift.Void)
  @_Concurrency.MainActor public func cancelPendingTransition()
  @_Concurrency.MainActor public func update(to cameraOptions: MapboxMaps.CameraOptions, state: MapboxNavigationCore.NavigationCameraState)
  @objc deinit
}
public enum NavigationCameraType {
  case carPlay
  case mobile
  public static func == (a: MapboxNavigationCore.NavigationCameraType, b: MapboxNavigationCore.NavigationCameraType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NavigationViewportDataSourceOptions : Swift.Equatable, Swift.Sendable {
  public var followingCameraOptions: MapboxNavigationCore.FollowingCameraOptions
  public var overviewCameraOptions: MapboxNavigationCore.OverviewCameraOptions
  public init()
  public init(followingCameraOptions: MapboxNavigationCore.FollowingCameraOptions, overviewCameraOptions: MapboxNavigationCore.OverviewCameraOptions)
  public static func == (lhs: MapboxNavigationCore.NavigationViewportDataSourceOptions, rhs: MapboxNavigationCore.NavigationViewportDataSourceOptions) -> Swift.Bool
}
public struct OverviewCameraOptions : Swift.Equatable, Swift.Sendable {
  public var maximumZoomLevel: Swift.Double {
    get
    set
  }
  public var centerUpdatesAllowed: Swift.Bool
  public var zoomUpdatesAllowed: Swift.Bool
  public var bearingUpdatesAllowed: Swift.Bool
  public var pitchUpdatesAllowed: Swift.Bool
  public var paddingUpdatesAllowed: Swift.Bool
  public init()
  public static func == (lhs: MapboxNavigationCore.OverviewCameraOptions, rhs: MapboxNavigationCore.OverviewCameraOptions) -> Swift.Bool
}
@_Concurrency.MainActor public class CarPlayViewportDataSource : MapboxNavigationCore.ViewportDataSource {
  @_Concurrency.MainActor required public init(_ mapView: MapboxMaps.MapView)
  @_Concurrency.MainActor public var options: MapboxNavigationCore.NavigationViewportDataSourceOptions {
    get
    set
  }
  @_Concurrency.MainActor public var navigationCameraOptions: Combine.AnyPublisher<MapboxNavigationCore.NavigationCameraOptions, Swift.Never> {
    get
  }
  @_Concurrency.MainActor public var currentNavigationCameraOptions: MapboxNavigationCore.NavigationCameraOptions {
    get
    set
  }
  @_Concurrency.MainActor public func update(using viewportState: MapboxNavigationCore.ViewportState)
  @objc deinit
}
@_Concurrency.MainActor public class MobileViewportDataSource : MapboxNavigationCore.ViewportDataSource {
  @_Concurrency.MainActor required public init(_ mapView: MapboxMaps.MapView)
  @_Concurrency.MainActor public var options: MapboxNavigationCore.NavigationViewportDataSourceOptions {
    get
    set
  }
  @_Concurrency.MainActor public var navigationCameraOptions: Combine.AnyPublisher<MapboxNavigationCore.NavigationCameraOptions, Swift.Never> {
    get
  }
  @_Concurrency.MainActor public var currentNavigationCameraOptions: MapboxNavigationCore.NavigationCameraOptions {
    get
    set
  }
  @_Concurrency.MainActor public func update(using viewportState: MapboxNavigationCore.ViewportState)
  @objc deinit
}
public struct ViewportState : Swift.Equatable, Swift.Sendable {
  public let location: CoreLocation.CLLocation
  public let routeProgress: MapboxNavigationCore.RouteProgress?
  public let viewportPadding: UIKit.UIEdgeInsets
  public let heading: CoreLocation.CLHeading?
  public init(location: CoreLocation.CLLocation, routeProgress: MapboxNavigationCore.RouteProgress?, viewportPadding: UIKit.UIEdgeInsets, heading: CoreLocation.CLHeading?)
  public static func == (a: MapboxNavigationCore.ViewportState, b: MapboxNavigationCore.ViewportState) -> Swift.Bool
}
@_Concurrency.MainActor public protocol ViewportDataSource : AnyObject {
  @_Concurrency.MainActor var options: MapboxNavigationCore.NavigationViewportDataSourceOptions { get }
  @_Concurrency.MainActor var navigationCameraOptions: Combine.AnyPublisher<MapboxNavigationCore.NavigationCameraOptions, Swift.Never> { get }
  @_Concurrency.MainActor var currentNavigationCameraOptions: MapboxNavigationCore.NavigationCameraOptions { get }
  @_Concurrency.MainActor func update(using viewportState: MapboxNavigationCore.ViewportState)
}
extension CoreLocation.CLHeading : @unchecked Swift.Sendable {
}
public struct MapPoint : Swift.Equatable, Swift.Sendable {
  public let name: Swift.String?
  public let coordinate: CoreLocation.CLLocationCoordinate2D
  public init(name: Swift.String?, coordinate: CoreLocation.CLLocationCoordinate2D)
  public static func == (a: MapboxNavigationCore.MapPoint, b: MapboxNavigationCore.MapPoint) -> Swift.Bool
}
extension MapboxNavigationCore.NavigationMapView : MapboxMaps.GestureManagerDelegate {
  nonisolated public func gestureManager(_ gestureManager: MapboxMaps.GestureManager, didBegin gestureType: MapboxMaps.GestureType)
  nonisolated public func gestureManager(_ gestureManager: MapboxMaps.GestureManager, didEnd gestureType: MapboxMaps.GestureType, willAnimate: Swift.Bool)
  nonisolated public func gestureManager(_ gestureManager: MapboxMaps.GestureManager, didEndAnimatingFor gestureType: MapboxMaps.GestureType)
}
extension MapboxNavigationCore.NavigationMapView : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor open class NavigationMapView : UIKit.UIView {
  @_Concurrency.MainActor final public let mapView: MapboxMaps.MapView
  @_Concurrency.MainActor final public let navigationCamera: MapboxNavigationCore.NavigationCamera
  @_Concurrency.MainActor weak public var delegate: (any MapboxNavigationCore.NavigationMapViewDelegate)?
  @_Concurrency.MainActor public var mapViewTapGestureRecognizer: UIKit.UITapGestureRecognizer! {
    get
  }
  @_Concurrency.MainActor public init(location: Combine.AnyPublisher<CoreLocation.CLLocation, Swift.Never>, routeProgress: Combine.AnyPublisher<MapboxNavigationCore.RouteProgress?, Swift.Never>, navigationCameraType: MapboxNavigationCore.NavigationCameraType = .mobile, heading: Combine.AnyPublisher<CoreLocation.CLHeading, Swift.Never>? = nil, predictiveCacheManager: MapboxNavigationCore.PredictiveCacheManager? = nil)
  @available(*, deprecated, message: "This property is deprecated and should no longer be used, as the final destination annotation is no longer added to the map. Use 'AnnotationOrchestrator.makePointAnnotationManager()' to create your own annotation manager instead. For more information see the following guide: https://docs.mapbox.com/ios/maps/guides/markers-and-annotations/annotations/#markers")
  @_Concurrency.MainActor public var pointAnnotationManager: MapboxMaps.PointAnnotationManager? {
    get
  }
  @available(*, unavailable)
  @_Concurrency.MainActor @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @available(*, unavailable)
  @_Concurrency.MainActor @objc dynamic public init()
  @available(*, unavailable)
  @_Concurrency.MainActor @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @objc override dynamic open func safeAreaInsetsDidChange()
  @_Concurrency.MainActor public var viewportPadding: UIKit.UIEdgeInsets {
    get
    set
  }
  @_Concurrency.MainActor public var showsIntersectionAnnotations: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor public var showsAlternatives: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor public var showsRelativeDurationsOnAlternativeManuever: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor public var routeLineTracksTraversal: Swift.Bool
  @_Concurrency.MainActor public var poiClickableAreaSize: CoreFoundation.CGFloat
  @_Concurrency.MainActor public var showsRestrictedAreasOnRoute: Swift.Bool
  @_Concurrency.MainActor public var routeLineOcclusionFactor: Swift.Double
  @_Concurrency.MainActor public var congestionConfiguration: MapboxNavigationCore.CongestionConfiguration
  @_Concurrency.MainActor public var showsTrafficOnRouteLine: Swift.Bool
  @_Concurrency.MainActor public var tapGestureDistanceThreshold: CoreFoundation.CGFloat
  @_Concurrency.MainActor public var showsVoiceInstructionsOnMap: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor public var showsIntermediateWaypoints: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor public var puckType: MapboxMaps.PuckType? {
    get
    set
  }
  @_Concurrency.MainActor public var puckBearing: MapboxMaps.PuckBearing {
    get
    set
  }
  @_Concurrency.MainActor public var customRouteLineLayerPosition: MapboxMaps.LayerPosition? {
    get
    set
  }
  @objc @_Concurrency.MainActor dynamic public var routeColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor dynamic public var routeAlternateColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor dynamic public var routeCasingColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var routeAlternateCasingColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var routeRestrictedAreaColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var traversedRouteColor: UIKit.UIColor?
  @objc @_Concurrency.MainActor dynamic public var maneuverArrowColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var maneuverArrowStrokeColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var routeAnnotationSelectedColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var routeAnnotationColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var routeAnnotationSelectedTextColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var routeAnnotationTextColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var routeAnnotationMoreTimeTextColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var routeAnnotationLessTimeTextColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var routeAnnotationTextFont: UIKit.UIFont
  @objc @_Concurrency.MainActor dynamic public var waypointColor: UIKit.UIColor
  @objc @_Concurrency.MainActor dynamic public var waypointStrokeColor: UIKit.UIColor
  @_Concurrency.MainActor public func update(navigationCameraState: MapboxNavigationCore.NavigationCameraState)
  @_Concurrency.MainActor public func updateFreeDriveAlertAnnotations(_ roadObjects: [MapboxNavigationCore.RoadObjectAhead])
  @_Concurrency.MainActor public func showcase(_ navigationRoutes: MapboxNavigationCore.NavigationRoutes, routesPresentationStyle: MapboxNavigationCore.RoutesPresentationStyle = .all(), routeAnnotationKinds: Swift.Set<MapboxNavigationCore.RouteAnnotationKind> = [.relativeDurationsOnAlternative], animated: Swift.Bool = false, duration: Foundation.TimeInterval = 1.0)
  @_Concurrency.MainActor public var excludedRouteAlertTypes: MapboxNavigationCore.RoadAlertType {
    get
    set
  }
  @_Concurrency.MainActor public func show(_ navigationRoutes: MapboxNavigationCore.NavigationRoutes, routeAnnotationKinds: Swift.Set<MapboxNavigationCore.RouteAnnotationKind>)
  @_Concurrency.MainActor public func removeRoutes()
  @_Concurrency.MainActor public func localizeLabels(locale: Foundation.Locale? = nil)
  @objc deinit
}
@_Concurrency.MainActor public protocol NavigationMapViewDelegate : AnyObject, MapboxNavigationCore.UnimplementedLogging {
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didSelect alternativeRoute: MapboxNavigationCore.AlternativeRoute)
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, userDidTap mapPoint: MapboxNavigationCore.MapPoint)
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, userDidLongTap mapPoint: MapboxNavigationCore.MapPoint)
  @_Concurrency.MainActor func navigationMapViewUserDidStartInteraction(_ navigationMapView: MapboxNavigationCore.NavigationMapView)
  @_Concurrency.MainActor func navigationMapViewUserDidEndInteraction(_ navigationMapView: MapboxNavigationCore.NavigationMapView)
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didChangeCameraState cameraState: MapboxNavigationCore.NavigationCameraState)
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didSelect waypoint: MapboxNavigationCore.Waypoint)
  @available(*, deprecated, message: "This method is deprecated and should no longer be used, as the final destination annotation is no longer added to the map. Use the corresponding delegate methods to customize waypoints appearance.")
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didAdd finalDestinationAnnotation: MapboxMaps.PointAnnotation, pointAnnotationManager: MapboxMaps.PointAnnotationManager)
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didAddRedrawActiveGuidanceRoutes navigationRoutes: MapboxNavigationCore.NavigationRoutes)
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, waypointCircleLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.CircleLayer?
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, waypointSymbolLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.SymbolLayer?
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, shapeFor waypoints: [MapboxNavigationCore.Waypoint], legIndex: Swift.Int) -> Turf.FeatureCollection?
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, routeLineLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.LineLayer?
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, routeCasingLineLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.LineLayer?
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, routeRestrictedAreasLineLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.LineLayer?
  @_Concurrency.MainActor func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, willAdd layer: any MapboxMaps.Layer) -> (any MapboxMaps.Layer)?
}
extension MapboxNavigationCore.NavigationMapViewDelegate {
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, routeLineLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.LineLayer?
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, routeCasingLineLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.LineLayer?
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, routeRestrictedAreasLineLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.LineLayer?
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didSelect alternativeRoute: MapboxNavigationCore.AlternativeRoute)
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, userDidTap mapPoint: MapboxNavigationCore.MapPoint)
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, userDidLongTap mapPoint: MapboxNavigationCore.MapPoint)
  @_Concurrency.MainActor public func navigationMapViewUserDidStartInteraction(_ navigationMapView: MapboxNavigationCore.NavigationMapView)
  @_Concurrency.MainActor public func navigationMapViewUserDidEndInteraction(_ navigationMapView: MapboxNavigationCore.NavigationMapView)
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didChangeCameraState cameraState: MapboxNavigationCore.NavigationCameraState)
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didSelect waypoint: MapboxNavigationCore.Waypoint)
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didAdd finalDestinationAnnotation: MapboxMaps.PointAnnotation, pointAnnotationManager: MapboxMaps.PointAnnotationManager)
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, didAddRedrawActiveGuidanceRoutes navigationRoutes: MapboxNavigationCore.NavigationRoutes)
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, shapeFor waypoints: [MapboxNavigationCore.Waypoint], legIndex: Swift.Int) -> Turf.FeatureCollection?
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, waypointCircleLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.CircleLayer?
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, waypointSymbolLayerWithIdentifier identifier: Swift.String, sourceIdentifier: Swift.String) -> MapboxMaps.SymbolLayer?
  @_Concurrency.MainActor public func navigationMapView(_ navigationMapView: MapboxNavigationCore.NavigationMapView, willAdd layer: any MapboxMaps.Layer) -> (any MapboxMaps.Layer)?
}
extension CoreLocation.CLLocationCoordinate2D {
  public func projectedDistance(to coordinate: CoreLocation.CLLocationCoordinate2D) -> Swift.Double
}
public let RouteLineWidthByZoomLevel: [Swift.Double : Swift.Double]
extension Swift.Dictionary where Key == Swift.Double, Value == Swift.Double {
  public func multiplied(by factor: Swift.Double) -> Swift.Dictionary<Key, Value>
}
extension MapboxMaps.Puck3DConfiguration {
  public static let navigationDefault: MapboxMaps.Puck3DConfiguration
  public static let navigationCarPlayDefault: MapboxMaps.Puck3DConfiguration
}
extension MapboxMaps.Puck2DConfiguration {
  public static let navigationDefault: MapboxMaps.Puck2DConfiguration
  public static let navigationCarPlayDefault: MapboxMaps.Puck2DConfiguration
}
public struct RoadAlertType : Swift.OptionSet {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let accident: MapboxNavigationCore.RoadAlertType
  public static let congestion: MapboxNavigationCore.RoadAlertType
  public static let construction: MapboxNavigationCore.RoadAlertType
  public static let disabledVehicle: MapboxNavigationCore.RoadAlertType
  public static let laneRestriction: MapboxNavigationCore.RoadAlertType
  public static let massTransit: MapboxNavigationCore.RoadAlertType
  public static let miscellaneous: MapboxNavigationCore.RoadAlertType
  public static let otherNews: MapboxNavigationCore.RoadAlertType
  public static let plannedEvent: MapboxNavigationCore.RoadAlertType
  public static let roadClosure: MapboxNavigationCore.RoadAlertType
  public static let roadHazard: MapboxNavigationCore.RoadAlertType
  public static let weather: MapboxNavigationCore.RoadAlertType
  public static let all: MapboxNavigationCore.RoadAlertType
  public typealias ArrayLiteralElement = MapboxNavigationCore.RoadAlertType
  public typealias Element = MapboxNavigationCore.RoadAlertType
  public typealias RawValue = Swift.UInt
}
extension MapboxDirections.Route {
  public var etaDistanceInfo: MapboxNavigationCore.EtaDistanceInfo? {
    get
  }
  public func etaDistanceInfo(forLeg index: Swift.Int) -> MapboxNavigationCore.EtaDistanceInfo?
}
public enum RoutesPresentationStyle {
  case main
  case all(shouldFit: Swift.Bool = true)
}
public struct CongestionColorsConfiguration : Swift.Equatable, Swift.Sendable {
  public var mainRouteColors: MapboxNavigationCore.CongestionColorsConfiguration.Colors
  public var alternativeRouteColors: MapboxNavigationCore.CongestionColorsConfiguration.Colors
  public static let `default`: MapboxNavigationCore.CongestionColorsConfiguration
  public init(mainRouteColors: MapboxNavigationCore.CongestionColorsConfiguration.Colors, alternativeRouteColors: MapboxNavigationCore.CongestionColorsConfiguration.Colors)
  public static func == (a: MapboxNavigationCore.CongestionColorsConfiguration, b: MapboxNavigationCore.CongestionColorsConfiguration) -> Swift.Bool
}
extension MapboxNavigationCore.CongestionColorsConfiguration {
  public struct Colors : Swift.Equatable, Swift.Sendable {
    public var low: UIKit.UIColor
    public var moderate: UIKit.UIColor
    public var heavy: UIKit.UIColor
    public var severe: UIKit.UIColor
    public var unknown: UIKit.UIColor
    public static let defaultMainRouteColors: MapboxNavigationCore.CongestionColorsConfiguration.Colors
    public static let defaultAlternativeRouteColors: MapboxNavigationCore.CongestionColorsConfiguration.Colors
    public init(low: UIKit.UIColor, moderate: UIKit.UIColor, heavy: UIKit.UIColor, severe: UIKit.UIColor, unknown: UIKit.UIColor)
    public static func == (a: MapboxNavigationCore.CongestionColorsConfiguration.Colors, b: MapboxNavigationCore.CongestionColorsConfiguration.Colors) -> Swift.Bool
  }
}
public struct CongestionConfiguration : Swift.Equatable, Swift.Sendable {
  public var colors: MapboxNavigationCore.CongestionColorsConfiguration
  public var ranges: MapboxNavigationCore.CongestionRangesConfiguration
  public static let `default`: MapboxNavigationCore.CongestionConfiguration
  public init(colors: MapboxNavigationCore.CongestionColorsConfiguration, ranges: MapboxNavigationCore.CongestionRangesConfiguration)
  public static func == (a: MapboxNavigationCore.CongestionConfiguration, b: MapboxNavigationCore.CongestionConfiguration) -> Swift.Bool
}
public enum RouteAnnotationKind {
  case routeDurations
  case relativeDurationsOnAlternative
  case relativeDurationsOnAlternativeManuever
  public static func == (a: MapboxNavigationCore.RouteAnnotationKind, b: MapboxNavigationCore.RouteAnnotationKind) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_Concurrency.MainActor public protocol ElectronicHorizonController : Swift.Sendable {
  @_Concurrency.MainActor var eHorizonEvents: Combine.AnyPublisher<MapboxNavigationCore.EHorizonStatus, Swift.Never> { get }
  @_Concurrency.MainActor var roadMatching: MapboxNavigationCore.RoadMatching { get }
  @_Concurrency.MainActor func startUpdatingEHorizon()
  @_Concurrency.MainActor func stopUpdatingEHorizon()
}
@_Concurrency.MainActor public protocol MapboxNavigation {
  @_Concurrency.MainActor func routingProvider() -> any MapboxNavigationCore.RoutingProvider
  @_Concurrency.MainActor func tripSession() -> any MapboxNavigationCore.SessionController
  @_Concurrency.MainActor func electronicHorizon() -> any MapboxNavigationCore.ElectronicHorizonController
  @_Concurrency.MainActor func navigation() -> any MapboxNavigationCore.NavigationController
  @_Concurrency.MainActor func eventsManager() -> MapboxNavigationCore.NavigationEventsManager
  @_Concurrency.MainActor func historyRecorder() -> (any MapboxNavigationCore.HistoryRecording)?
  @_Concurrency.MainActor func copilot() -> MapboxNavigationCore.CopilotService?
}
@_Concurrency.MainActor public protocol NavigationController : Swift.Sendable {
  @_Concurrency.MainActor func selectAlternativeRoute(at index: Swift.Int)
  @_Concurrency.MainActor func selectAlternativeRoute(with routeId: MapboxNavigationCore.RouteId)
  @_Concurrency.MainActor func switchLeg(newLegIndex: Swift.Int)
  @_Concurrency.MainActor var heading: Combine.AnyPublisher<CoreLocation.CLHeading, Swift.Never> { get }
  @_Concurrency.MainActor var locationMatching: Combine.AnyPublisher<MapboxNavigationCore.MapMatchingState, Swift.Never> { get }
  @_Concurrency.MainActor var currentLocationMatching: MapboxNavigationCore.MapMatchingState? { get }
  @_Concurrency.MainActor var routeProgress: Combine.AnyPublisher<MapboxNavigationCore.RouteProgressState?, Swift.Never> { get }
  @_Concurrency.MainActor var currentRouteProgress: MapboxNavigationCore.RouteProgressState? { get }
  @_Concurrency.MainActor var offlineFallbacks: Combine.AnyPublisher<MapboxNavigationCore.FallbackToTilesState, Swift.Never> { get }
  @_Concurrency.MainActor var voiceInstructions: Combine.AnyPublisher<MapboxNavigationCore.SpokenInstructionState, Swift.Never> { get }
  @_Concurrency.MainActor var bannerInstructions: Combine.AnyPublisher<MapboxNavigationCore.VisualInstructionState, Swift.Never> { get }
  @_Concurrency.MainActor var waypointsArrival: Combine.AnyPublisher<MapboxNavigationCore.WaypointArrivalStatus, Swift.Never> { get }
  @_Concurrency.MainActor var rerouting: Combine.AnyPublisher<MapboxNavigationCore.ReroutingStatus, Swift.Never> { get }
  @_Concurrency.MainActor var continuousAlternatives: Combine.AnyPublisher<MapboxNavigationCore.AlternativesStatus, Swift.Never> { get }
  @_Concurrency.MainActor var fasterRoutes: Combine.AnyPublisher<MapboxNavigationCore.FasterRoutesStatus, Swift.Never> { get }
  @_Concurrency.MainActor var routeRefreshing: Combine.AnyPublisher<MapboxNavigationCore.RefreshingStatus, Swift.Never> { get }
  @_Concurrency.MainActor var errors: Combine.AnyPublisher<any MapboxNavigationCore.NavigatorError, Swift.Never> { get }
}
@_Concurrency.MainActor public protocol SessionController : Swift.Sendable {
  @_Concurrency.MainActor func startFreeDrive()
  @_Concurrency.MainActor func pauseFreeDrive()
  @_Concurrency.MainActor func setToIdle()
  @_Concurrency.MainActor func startActiveGuidance(with navigationRoutes: MapboxNavigationCore.NavigationRoutes, startLegIndex: Swift.Int)
  @_Concurrency.MainActor var session: Combine.AnyPublisher<MapboxNavigationCore.Session, Swift.Never> { get }
  @_Concurrency.MainActor var currentSession: MapboxNavigationCore.Session { get }
  @_Concurrency.MainActor var navigationRoutes: Combine.AnyPublisher<MapboxNavigationCore.NavigationRoutes?, Swift.Never> { get }
  @_Concurrency.MainActor var currentNavigationRoutes: MapboxNavigationCore.NavigationRoutes? { get }
  @_Concurrency.MainActor func disableTrackingBackgroundLocationIfNeeded()
  @_Concurrency.MainActor func restoreTrackingLocationIfNeeded()
}
final public class MapboxNavigationProvider {
  final public var skuTokenProvider: MapboxNavigationCore.SkuTokenProvider {
    get
  }
  final public var predictiveCacheManager: MapboxNavigationCore.PredictiveCacheManager? {
    get
  }
  @_Concurrency.MainActor final public var routeVoiceController: MapboxNavigationCore.RouteVoiceController {
    get
  }
  final public var coreConfig: MapboxNavigationCore.CoreConfig {
    get
  }
  public init(coreConfig: MapboxNavigationCore.CoreConfig)
  final public func apply(coreConfig: MapboxNavigationCore.CoreConfig)
  @_Concurrency.MainActor final public var mapboxNavigation: any MapboxNavigationCore.MapboxNavigation {
    get
  }
  final public func getLatestNavigationTilesetDescriptor() -> MapboxCommon.TilesetDescriptor
  @objc deinit
}
extension MapboxNavigationCore.MapboxNavigationProvider : MapboxNavigationCore.MapboxNavigation {
  @_Concurrency.MainActor final public func routingProvider() -> any MapboxNavigationCore.RoutingProvider
  @_Concurrency.MainActor final public func tripSession() -> any MapboxNavigationCore.SessionController
  @_Concurrency.MainActor final public func electronicHorizon() -> any MapboxNavigationCore.ElectronicHorizonController
  @_Concurrency.MainActor final public func navigation() -> any MapboxNavigationCore.NavigationController
  @_Concurrency.MainActor final public func eventsManager() -> MapboxNavigationCore.NavigationEventsManager
  @_Concurrency.MainActor final public func historyRecorder() -> (any MapboxNavigationCore.HistoryRecording)?
  @_Concurrency.MainActor final public func copilot() -> MapboxNavigationCore.CopilotService?
}
public struct AlternativeRoute : @unchecked Swift.Sendable {
  public let route: MapboxDirections.Route
  public typealias ID = Swift.UInt32
  public struct RouteInfo {
    public let distance: Turf.LocationDistance
    public let duration: Foundation.TimeInterval
    public init(distance: Turf.LocationDistance, duration: Foundation.TimeInterval)
  }
  public struct IntersectionGeometryIndices {
    public let legIndex: Swift.Int
    public let legGeometryIndex: Swift.Int
    public let routeGeometryIndex: Swift.Int
  }
  public let id: MapboxNavigationCore.AlternativeRoute.ID
  public let routeId: MapboxNavigationCore.RouteId
  public let mainRouteIntersection: MapboxDirections.Intersection
  public let mainRouteIntersectionIndices: MapboxNavigationCore.AlternativeRoute.IntersectionGeometryIndices
  public let alternativeRouteIntersection: MapboxDirections.Intersection
  public let alternativeRouteIntersectionIndices: MapboxNavigationCore.AlternativeRoute.IntersectionGeometryIndices
  public let infoFromDeviationPoint: MapboxNavigationCore.AlternativeRoute.RouteInfo
  public let infoFromOrigin: MapboxNavigationCore.AlternativeRoute.RouteInfo
  public let distanceDelta: Turf.LocationDistance
  public let expectedTravelTimeDelta: Foundation.TimeInterval
  public init?(mainRoute: MapboxDirections.Route, alternativeRoute nativeRouteAlternative: MapboxNavigationNative.RouteAlternative) async
}
extension MapboxNavigationCore.AlternativeRoute : Swift.Equatable {
  public static func == (lhs: MapboxNavigationCore.AlternativeRoute, rhs: MapboxNavigationCore.AlternativeRoute) -> Swift.Bool
}
public struct BorderCrossing : Swift.Equatable {
  public let from: MapboxDirections.AdministrativeRegion
  public let to: MapboxDirections.AdministrativeRegion
  public init(from: MapboxDirections.AdministrativeRegion, to: MapboxDirections.AdministrativeRegion)
  public static func == (a: MapboxNavigationCore.BorderCrossing, b: MapboxNavigationCore.BorderCrossing) -> Swift.Bool
}
public enum DistancedRoadObject : Swift.Sendable, Swift.Equatable {
  case point(identifier: MapboxNavigationCore.RoadObject.Identifier, kind: MapboxNavigationCore.RoadObject.Kind, distance: CoreLocation.CLLocationDistance)
  case gantry(identifier: MapboxNavigationCore.RoadObject.Identifier, kind: MapboxNavigationCore.RoadObject.Kind, distance: CoreLocation.CLLocationDistance)
  case polygon(identifier: MapboxNavigationCore.RoadObject.Identifier, kind: MapboxNavigationCore.RoadObject.Kind, distanceToNearestEntry: CoreLocation.CLLocationDistance?, distanceToNearestExit: CoreLocation.CLLocationDistance?, isInside: Swift.Bool)
  case subgraph(identifier: MapboxNavigationCore.RoadObject.Identifier, kind: MapboxNavigationCore.RoadObject.Kind, distanceToNearestEntry: CoreLocation.CLLocationDistance?, distanceToNearestExit: CoreLocation.CLLocationDistance?, isInside: Swift.Bool)
  case line(identifier: MapboxNavigationCore.RoadObject.Identifier, kind: MapboxNavigationCore.RoadObject.Kind, distanceToEntry: CoreLocation.CLLocationDistance, distanceToExit: CoreLocation.CLLocationDistance, distanceToEnd: CoreLocation.CLLocationDistance, isEntryFromStart: Swift.Bool, length: CoreLocation.CLLocationDistance)
  public var identifier: MapboxNavigationCore.RoadObject.Identifier {
    get
  }
  public var kind: MapboxNavigationCore.RoadObject.Kind {
    get
  }
  public static func == (a: MapboxNavigationCore.DistancedRoadObject, b: MapboxNavigationCore.DistancedRoadObject) -> Swift.Bool
}
public struct ElectronicHorizonConfig : Swift.Equatable, Swift.Sendable {
  public let length: CoreLocation.CLLocationDistance
  public let expansionLevel: Swift.UInt
  public let branchLength: CoreLocation.CLLocationDistance
  public let minimumTimeIntervalBetweenUpdates: Foundation.TimeInterval?
  public init(length: CoreLocation.CLLocationDistance, expansionLevel: Swift.UInt, branchLength: CoreLocation.CLLocationDistance, minTimeDeltaBetweenUpdates: Foundation.TimeInterval?)
  public static func == (a: MapboxNavigationCore.ElectronicHorizonConfig, b: MapboxNavigationCore.ElectronicHorizonConfig) -> Swift.Bool
}
public struct Interchange : Swift.Equatable {
  public var identifier: Swift.String
  public let names: [MapboxNavigationCore.LocalizedRoadObjectName]
  public init(names: [MapboxNavigationCore.LocalizedRoadObjectName])
  public init(identifier: Swift.String, names: [MapboxNavigationCore.LocalizedRoadObjectName])
  public static func == (a: MapboxNavigationCore.Interchange, b: MapboxNavigationCore.Interchange) -> Swift.Bool
}
public struct Junction : Swift.Equatable {
  public var identifier: Swift.String
  public let names: [MapboxNavigationCore.LocalizedRoadObjectName]
  public init(names: [MapboxNavigationCore.LocalizedRoadObjectName])
  public init(identifier: Swift.String, names: [MapboxNavigationCore.LocalizedRoadObjectName])
  public static func == (a: MapboxNavigationCore.Junction, b: MapboxNavigationCore.Junction) -> Swift.Bool
}
public struct LocalizedRoadObjectName : Swift.Equatable {
  public let language: Swift.String
  public let text: Swift.String
  public init(language: Swift.String, text: Swift.String)
  public static func == (a: MapboxNavigationCore.LocalizedRoadObjectName, b: MapboxNavigationCore.LocalizedRoadObjectName) -> Swift.Bool
}
public enum OpenLRIdentifier {
  case tomTom(reference: MapboxNavigationCore.RoadObject.Identifier)
  case tpeg(reference: MapboxNavigationCore.RoadObject.Identifier)
}
public enum OpenLROrientation : Swift.Equatable, Swift.Sendable {
  case unknown
  case alongLine
  case againstLine
  case both
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxNavigationCore.OpenLROrientation, b: MapboxNavigationCore.OpenLROrientation) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum OpenLRSideOfRoad : Swift.Equatable, Swift.Sendable {
  case unknown
  case right
  case left
  case both
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxNavigationCore.OpenLRSideOfRoad, b: MapboxNavigationCore.OpenLRSideOfRoad) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RoadGraph : Swift.Sendable {
  final public func edgeMetadata(edgeIdentifier: MapboxNavigationCore.RoadGraph.Edge.Identifier) -> MapboxNavigationCore.RoadGraph.Edge.Metadata?
  final public func edgeShape(edgeIdentifier: MapboxNavigationCore.RoadGraph.Edge.Identifier) -> Turf.LineString?
  final public func shape(of path: MapboxNavigationCore.RoadGraph.Path) -> Turf.LineString?
  final public func shape(of position: MapboxNavigationCore.RoadGraph.Position) -> Turf.Point?
  @objc deinit
}
extension MapboxNavigationNative.GraphAccessor : @unchecked Swift.Sendable {
}
extension MapboxNavigationCore.RoadGraph {
  public struct Edge : Swift.Equatable, Swift.Sendable {
    public typealias Identifier = Swift.UInt
    public let identifier: MapboxNavigationCore.RoadGraph.Edge.Identifier
    public let level: Swift.UInt
    public let probability: Swift.Double
    public let outletEdges: [MapboxNavigationCore.RoadGraph.Edge]
    public init(identifier: MapboxNavigationCore.RoadGraph.Edge.Identifier, level: Swift.UInt, probability: Swift.Double, outletEdges: [MapboxNavigationCore.RoadGraph.Edge])
    public static func == (a: MapboxNavigationCore.RoadGraph.Edge, b: MapboxNavigationCore.RoadGraph.Edge) -> Swift.Bool
  }
}
extension MapboxNavigationCore.RoadGraph.Edge {
  public enum Directionality : Swift.Sendable {
    case oneWay
    case bothWays
    public static func == (a: MapboxNavigationCore.RoadGraph.Edge.Directionality, b: MapboxNavigationCore.RoadGraph.Edge.Directionality) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Metadata : Swift.Sendable {
    public let heading: CoreLocation.CLLocationDegrees
    public let length: CoreLocation.CLLocationDistance
    public let altitude: CoreLocation.CLLocationDistance?
    public let curvature: Swift.UInt
    public let isBridge: Swift.Bool
    public let roadClasses: MapboxNavigationCore.RoadClasses
    public let mapboxStreetsRoadClass: MapboxDirections.MapboxStreetsRoadClass
    public let names: [MapboxNavigationCore.RoadName]
    public let countryCode: Swift.String?
    public let regionCode: Swift.String?
    public let directionality: MapboxNavigationCore.RoadGraph.Edge.Directionality
    public let speedLimit: Foundation.Measurement<Foundation.UnitSpeed>?
    public let speed: CoreLocation.CLLocationSpeed
    public let drivingSide: MapboxDirections.DrivingSide
    public let laneCount: Swift.UInt?
    public let isUrban: Swift.Bool
    public init(heading: CoreLocation.CLLocationDegrees, length: CoreLocation.CLLocationDistance, roadClasses: MapboxNavigationCore.RoadClasses, mapboxStreetsRoadClass: MapboxDirections.MapboxStreetsRoadClass, speedLimit: Foundation.Measurement<Foundation.UnitSpeed>?, speed: CoreLocation.CLLocationSpeed, isBridge: Swift.Bool, names: [MapboxNavigationCore.RoadName], laneCount: Swift.UInt?, altitude: CoreLocation.CLLocationDistance?, curvature: Swift.UInt, countryCode: Swift.String?, regionCode: Swift.String?, drivingSide: MapboxDirections.DrivingSide, directionality: MapboxNavigationCore.RoadGraph.Edge.Directionality, isUrban: Swift.Bool)
  }
}
extension MapboxNavigationCore.RoadGraph {
  public struct Path : Swift.Equatable, Swift.Sendable {
    public let edgeIdentifiers: [MapboxNavigationCore.RoadGraph.Edge.Identifier]
    public let fractionFromStart: Swift.Double
    public let fractionToEnd: Swift.Double
    public let length: CoreLocation.CLLocationDistance
    public init(edgeIdentifiers: [MapboxNavigationCore.RoadGraph.Edge.Identifier], fractionFromStart: Swift.Double, fractionToEnd: Swift.Double, length: CoreLocation.CLLocationDistance)
    public static func == (a: MapboxNavigationCore.RoadGraph.Path, b: MapboxNavigationCore.RoadGraph.Path) -> Swift.Bool
  }
}
extension MapboxNavigationCore.RoadGraph {
  public struct Position : Swift.Equatable, Swift.Sendable {
    public let edgeIdentifier: MapboxNavigationCore.RoadGraph.Edge.Identifier
    public let fractionFromStart: Swift.Double
    public init(edgeIdentifier: MapboxNavigationCore.RoadGraph.Edge.Identifier, fractionFromStart: Swift.Double)
    public static func == (a: MapboxNavigationCore.RoadGraph.Position, b: MapboxNavigationCore.RoadGraph.Position) -> Swift.Bool
  }
}
public struct RoadName : Swift.Equatable, Swift.Sendable {
  public let text: Swift.String
  public let language: Swift.String
  public let shield: MapboxNavigationCore.RoadShield?
  public init(text: Swift.String, language: Swift.String, shield: MapboxNavigationCore.RoadShield? = nil)
  public static func == (a: MapboxNavigationCore.RoadName, b: MapboxNavigationCore.RoadName) -> Swift.Bool
}
public struct RoadObjectAhead : Swift.Equatable, Swift.Sendable {
  public var roadObject: MapboxNavigationCore.RoadObject
  public var distance: CoreLocation.CLLocationDistance?
  public init(roadObject: MapboxNavigationCore.RoadObject, distance: CoreLocation.CLLocationDistance? = nil)
  public static func == (a: MapboxNavigationCore.RoadObjectAhead, b: MapboxNavigationCore.RoadObjectAhead) -> Swift.Bool
}
public struct RoadObject : Swift.Equatable, Swift.Sendable {
  public let identifier: MapboxNavigationCore.RoadObject.Identifier
  public let length: CoreLocation.CLLocationDistance?
  public let location: MapboxNavigationCore.RoadObject.Location
  public let kind: MapboxNavigationCore.RoadObject.Kind
  public let isUserDefined: Swift.Bool
  public let isUrban: Swift.Bool?
  public init(identifier: MapboxNavigationCore.RoadObject.Identifier, length: CoreLocation.CLLocationDistance?, location: MapboxNavigationCore.RoadObject.Location, kind: MapboxNavigationCore.RoadObject.Kind, isUrban: Swift.Bool?)
  public init(_ native: MapboxNavigationNative.RoadObject)
  public static func == (a: MapboxNavigationCore.RoadObject, b: MapboxNavigationCore.RoadObject) -> Swift.Bool
}
extension MapboxNavigationCore.RoadObject {
  public struct EdgeLocation {
    public let fractionFromStart: Swift.Double
    public let fractionToEnd: Swift.Double
    public init(fractionFromStart: Swift.Double, fractionToEnd: Swift.Double)
  }
}
extension MapboxNavigationCore.RoadObject {
  public enum Kind : Swift.Equatable, @unchecked Swift.Sendable {
    case incident(MapboxDirections.Incident?)
    case tollCollection(MapboxDirections.TollCollection?)
    case borderCrossing(MapboxNavigationCore.BorderCrossing?)
    case tunnel(MapboxNavigationCore.Tunnel?)
    case serviceArea(MapboxDirections.RestStop?)
    case restrictedArea
    case bridge
    case railroadCrossing
    case userDefined
    case ic(MapboxNavigationCore.Interchange?)
    case jct(MapboxNavigationCore.Junction?)
    case undefined
    public static func == (a: MapboxNavigationCore.RoadObject.Kind, b: MapboxNavigationCore.RoadObject.Kind) -> Swift.Bool
  }
}
extension MapboxNavigationCore.RoadObject {
  public enum Location : Swift.Equatable, Swift.Sendable {
    case gantry(positions: [MapboxNavigationCore.RoadObject.Position], shape: Turf.Geometry)
    case point(position: MapboxNavigationCore.RoadObject.Position)
    case polygon(entries: [MapboxNavigationCore.RoadObject.Position], exits: [MapboxNavigationCore.RoadObject.Position], shape: Turf.Geometry)
    case polyline(path: MapboxNavigationCore.RoadGraph.Path, shape: Turf.Geometry)
    case subgraph(enters: [MapboxNavigationCore.RoadObject.Position], exits: [MapboxNavigationCore.RoadObject.Position], shape: Turf.Geometry, edges: [MapboxNavigationCore.RoadGraph.SubgraphEdge.Identifier : MapboxNavigationCore.RoadGraph.SubgraphEdge])
    case openLRLine(path: MapboxNavigationCore.RoadGraph.Path, shape: Turf.Geometry)
    case openLRPoint(position: MapboxNavigationCore.RoadGraph.Position, sideOfRoad: MapboxNavigationCore.OpenLRSideOfRoad, orientation: MapboxNavigationCore.OpenLROrientation, coordinate: CoreLocation.CLLocationCoordinate2D)
    case routeAlert(shape: Turf.Geometry)
    public static func == (a: MapboxNavigationCore.RoadObject.Location, b: MapboxNavigationCore.RoadObject.Location) -> Swift.Bool
  }
}
@_hasMissingDesignatedInitializers final public class RoadObjectMatcher : @unchecked Swift.Sendable {
  final public func matchOpenLR(location: Swift.String, identifier: MapboxNavigationCore.OpenLRIdentifier)
  final public func match(polyline: Turf.LineString, identifier: MapboxNavigationCore.RoadObject.Identifier)
  final public func match(polygon: Turf.Polygon, identifier: MapboxNavigationCore.RoadObject.Identifier)
  final public func match(gantry: Turf.MultiPoint, identifier: MapboxNavigationCore.RoadObject.Identifier)
  final public func match(point: CoreLocation.CLLocationCoordinate2D, identifier: MapboxNavigationCore.RoadObject.Identifier, heading: CoreLocation.CLHeading? = nil)
  final public func cancel(identifier: MapboxNavigationCore.RoadObject.Identifier)
  weak final public var delegate: (any MapboxNavigationCore.RoadObjectMatcherDelegate)? {
    get
    set
  }
  @objc deinit
}
extension MapboxNavigationNative.RoadObjectMatcherError : Swift.Error, @unchecked Swift.Sendable {
}
public protocol RoadObjectMatcherDelegate : AnyObject {
  func roadObjectMatcher(_ matcher: MapboxNavigationCore.RoadObjectMatcher, didMatch roadObject: MapboxNavigationCore.RoadObject)
  func roadObjectMatcher(_ matcher: MapboxNavigationCore.RoadObjectMatcher, didFailToMatchWith error: MapboxNavigationCore.RoadObjectMatcherError)
  func roadObjectMatcher(_ matcher: MapboxNavigationCore.RoadObjectMatcher, didCancelMatchingFor id: Swift.String)
}
public struct RoadObjectMatcherError : Foundation.LocalizedError {
  public let description: Swift.String
  public let roadObjectIdentifier: MapboxNavigationCore.RoadObject.Identifier
  public var errorDescription: Swift.String? {
    get
  }
  public init(description: Swift.String, roadObjectIdentifier: MapboxNavigationCore.RoadObject.Identifier)
}
extension MapboxNavigationCore.RoadObject {
  public struct Position : Swift.Equatable, Swift.Sendable {
    public let position: MapboxNavigationCore.RoadGraph.Position
    public let coordinate: CoreLocation.CLLocationCoordinate2D
    public init(position: MapboxNavigationCore.RoadGraph.Position, coordinate: CoreLocation.CLLocationCoordinate2D)
    public static func == (a: MapboxNavigationCore.RoadObject.Position, b: MapboxNavigationCore.RoadObject.Position) -> Swift.Bool
  }
}
extension MapboxNavigationCore.RoadObject {
  public typealias Identifier = Swift.String
}
@_hasMissingDesignatedInitializers final public class RoadObjectStore : @unchecked Swift.Sendable {
  weak final public var delegate: (any MapboxNavigationCore.RoadObjectStoreDelegate)? {
    get
    set
  }
  final public func roadObjectEdgeLocations(edgeIdentifier: MapboxNavigationCore.RoadGraph.Edge.Identifier) -> [MapboxNavigationCore.RoadObject.Identifier : MapboxNavigationCore.RoadObject.EdgeLocation]
  final public func roadObject(identifier roadObjectIdentifier: MapboxNavigationCore.RoadObject.Identifier) -> MapboxNavigationCore.RoadObject?
  final public func roadObjectIdentifiers(edgeIdentifiers: [MapboxNavigationCore.RoadGraph.Edge.Identifier]) -> [MapboxNavigationCore.RoadObject.Identifier]
  final public func addUserDefinedRoadObject(_ roadObject: MapboxNavigationCore.RoadObject)
  final public func removeUserDefinedRoadObject(identifier: MapboxNavigationCore.RoadObject.Identifier)
  final public func removeAllUserDefinedRoadObjects()
  @objc deinit
}
extension MapboxNavigationCore.RoadObjectStore : MapboxNavigationNative.RoadObjectsStoreObserver {
  @objc final public func onRoadObjectAdded(forId id: Swift.String)
  @objc final public func onRoadObjectUpdated(forId id: Swift.String)
  @objc final public func onRoadObjectRemoved(forId id: Swift.String)
}
public protocol RoadObjectStoreDelegate : AnyObject {
  func didAddRoadObject(identifier: MapboxNavigationCore.RoadObject.Identifier)
  func didUpdateRoadObject(identifier: MapboxNavigationCore.RoadObject.Identifier)
  func didRemoveRoadObject(identifier: MapboxNavigationCore.RoadObject.Identifier)
}
public struct RoadShield : Swift.Equatable, Swift.Sendable {
  public let baseUrl: Swift.String
  public let displayRef: Swift.String
  public let name: Swift.String
  public let textColor: Swift.String
  public init(baseUrl: Swift.String, displayRef: Swift.String, name: Swift.String, textColor: Swift.String)
  public static func == (a: MapboxNavigationCore.RoadShield, b: MapboxNavigationCore.RoadShield) -> Swift.Bool
}
extension MapboxNavigationCore.RoadGraph {
  public struct SubgraphEdge : Swift.Equatable, Swift.Sendable {
    public typealias Identifier = MapboxNavigationCore.RoadGraph.Edge.Identifier
    public let identifier: MapboxNavigationCore.RoadGraph.SubgraphEdge.Identifier
    public let innerEdgeIds: [MapboxNavigationCore.RoadGraph.SubgraphEdge.Identifier]
    public let outerEdgeIds: [MapboxNavigationCore.RoadGraph.SubgraphEdge.Identifier]
    public let length: CoreLocation.CLLocationDistance
    public let shape: Turf.Geometry
    public init(identifier: MapboxNavigationCore.RoadGraph.SubgraphEdge.Identifier, innerEdgeIds: [MapboxNavigationCore.RoadGraph.SubgraphEdge.Identifier], outerEdgeIds: [MapboxNavigationCore.RoadGraph.SubgraphEdge.Identifier], length: CoreLocation.CLLocationDistance, shape: Turf.Geometry)
    public static func == (a: MapboxNavigationCore.RoadGraph.SubgraphEdge, b: MapboxNavigationCore.RoadGraph.SubgraphEdge) -> Swift.Bool
  }
}
public struct RouteAlert : Swift.Equatable, Swift.Sendable {
  public let roadObject: MapboxNavigationCore.RoadObject
  public let distanceToStart: CoreLocation.CLLocationDistance
  public static func == (a: MapboxNavigationCore.RouteAlert, b: MapboxNavigationCore.RouteAlert) -> Swift.Bool
}
public struct EtaDistanceInfo : Swift.Equatable, Swift.Sendable {
  public var distance: CoreLocation.CLLocationDistance
  public var travelTime: Foundation.TimeInterval?
  public init(distance: CoreLocation.CLLocationDistance, travelTime: Foundation.TimeInterval?)
  public static func == (a: MapboxNavigationCore.EtaDistanceInfo, b: MapboxNavigationCore.EtaDistanceInfo) -> Swift.Bool
}
public protocol FasterRouteProvider : AnyObject {
  var isRerouting: Swift.Bool { get set }
  var navigationRoute: MapboxNavigationCore.NavigationRoute? { get set }
  var currentLocation: CoreLocation.CLLocation? { get set }
  var fasterRoutes: Combine.AnyPublisher<MapboxNavigationCore.NavigationRoutes, Swift.Never> { get }
  func checkForFasterRoute(from routeProgress: MapboxNavigationCore.RouteProgress)
}
extension MapboxNavigationNative.ElectronicHorizonOptions : @unchecked Swift.Sendable {
}
public enum ReroutingError : Swift.Error {
  case routeError
  case wrongRequest
  case unknown
  case cancelled
  case noRoutesOrController
  case anotherRerouteInProgress
  public static func == (a: MapboxNavigationCore.ReroutingError, b: MapboxNavigationCore.ReroutingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MapboxCommon_Private.MovementInfo : @unchecked Swift.Sendable {
}
public let customConfigKey: Swift.String
public let customConfigFeaturesKey: Swift.String
public struct LocationClient : @unchecked Swift.Sendable, Swift.Equatable {
  public init(locations: Combine.AnyPublisher<CoreLocation.CLLocation, Swift.Never>, headings: Combine.AnyPublisher<CoreLocation.CLHeading, Swift.Never>, startUpdatingLocation: @escaping () -> Swift.Void, stopUpdatingLocation: @escaping () -> Swift.Void, startUpdatingHeading: @escaping () -> Swift.Void, stopUpdatingHeading: @escaping () -> Swift.Void)
  public static func == (lhs: MapboxNavigationCore.LocationClient, rhs: MapboxNavigationCore.LocationClient) -> Swift.Bool
}
public enum LocationSource : Swift.Equatable, @unchecked Swift.Sendable {
  case simulation(initialLocation: CoreLocation.CLLocation? = nil)
  case live
  case custom(MapboxNavigationCore.LocationClient)
  public static func == (a: MapboxNavigationCore.LocationSource, b: MapboxNavigationCore.LocationSource) -> Swift.Bool
}
@_hasMissingDesignatedInitializers @_Concurrency.MainActor final public class MultiplexLocationClient : @unchecked Swift.Sendable {
  @objc deinit
}
public struct MapMatchingResult : Swift.Equatable, @unchecked Swift.Sendable {
  public var enhancedLocation: CoreLocation.CLLocation
  public var keyPoints: [CoreLocation.CLLocation]
  public var isOffRoad: Swift.Bool
  public var offRoadProbability: Swift.Double
  public var isTeleport: Swift.Bool
  public var roadEdgeMatchProbability: Swift.Double
  @_documentation(visibility: internal) public init(enhancedLocation: CoreLocation.CLLocation, keyPoints: [CoreLocation.CLLocation], isOffRoad: Swift.Bool, offRoadProbability: Swift.Double, isTeleport: Swift.Bool, roadEdgeMatchProbability: Swift.Double)
  public static func == (a: MapboxNavigationCore.MapMatchingResult, b: MapboxNavigationCore.MapMatchingResult) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers open class NavigationLocationManager : CoreLocation.CLLocationManager {
  @_Concurrency.MainActor @objc override dynamic public init()
  open var simulatesLocation: Swift.Bool
  weak public var locationDelegate: (any MapboxNavigationCore.NavigationLocationManagerDelegate)?
  @objc deinit
}
public protocol NavigationLocationManagerDelegate : AnyObject {
  func navigationLocationManager(_ locationManager: MapboxNavigationCore.NavigationLocationManager, didReceiveNewLocation location: CoreLocation.CLLocation)
}
extension MapboxNavigationCore.NavigationLocationManager : CoreLocation.CLLocationManagerDelegate {
  @objc dynamic open func locationManager(_ manager: CoreLocation.CLLocationManager, didUpdateLocations locations: [CoreLocation.CLLocation])
}
public struct NavigationRoutes : Swift.Equatable, @unchecked Swift.Sendable {
  public var mainRoute: MapboxNavigationCore.NavigationRoute {
    get
  }
  public var alternativeRoutes: [MapboxNavigationCore.AlternativeRoute] {
    get
  }
  public var waypoints: [MapboxNavigationCore.Waypoint] {
    get
  }
  public var refreshInvalidationDate: Foundation.Date? {
    get
  }
  public var foreignMembers: Turf.JSONObject {
    get
  }
  public func selectingAlternativeRoute(at index: Swift.Int) async -> MapboxNavigationCore.NavigationRoutes?
  public func selecting(alternativeRoute: MapboxNavigationCore.AlternativeRoute) async -> MapboxNavigationCore.NavigationRoutes?
  public func allRoutes(_ isIncluded: (MapboxDirections.Route) -> Swift.Bool = { _ in true }) -> [MapboxDirections.Route]
  public func containsSameRoutes(as otherRoutes: MapboxNavigationCore.NavigationRoutes) -> Swift.Bool
  public static func == (a: MapboxNavigationCore.NavigationRoutes, b: MapboxNavigationCore.NavigationRoutes) -> Swift.Bool
}
public struct NavigationRoute : Swift.Sendable {
  public let route: MapboxDirections.Route
  public let routeId: MapboxNavigationCore.RouteId
  public let nativeRoute: any MapboxNavigationNative.RouteInterface
  public init?(nativeRoute: any MapboxNavigationNative.RouteInterface) async
  public var routeOptions: MapboxDirections.RouteOptions? {
    get
  }
}
extension MapboxNavigationCore.NavigationRoute : Swift.Equatable {
  public static func == (lhs: MapboxNavigationCore.NavigationRoute, rhs: MapboxNavigationCore.NavigationRoute) -> Swift.Bool
}
public struct RouteId : Swift.Hashable, Swift.Sendable, Swift.Codable, Swift.CustomStringConvertible {
  public init(rawValue: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public var description: Swift.String {
    get
  }
  public static func == (a: MapboxNavigationCore.RouteId, b: MapboxNavigationCore.RouteId) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NavigationRoutesError : Swift.Error {
  case encodingError(underlyingError: (any Swift.Error)?)
  case responseParsingError(description: Swift.String)
  case noRequestData
  case emptyRoutes
  case incorrectRoutesNumber
  case unknownError
}
public protocol NavigationEvent : Swift.Equatable, Swift.Sendable {
}
public struct Session : Swift.Equatable, Swift.Sendable {
  public let state: MapboxNavigationCore.Session.State
  public enum State : Swift.Equatable, Swift.Sendable {
    case idle
    case freeDrive(MapboxNavigationCore.Session.State.FreeDriveState)
    case activeGuidance(MapboxNavigationCore.Session.State.ActiveGuidanceState)
    public var isTripSessionActive: Swift.Bool {
      get
    }
    public enum FreeDriveState : Swift.Sendable {
      case paused
      case active
      public static func == (a: MapboxNavigationCore.Session.State.FreeDriveState, b: MapboxNavigationCore.Session.State.FreeDriveState) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum ActiveGuidanceState : Swift.Sendable {
      case initialized
      case tracking
      case offRoute
      case uncertain
      case complete
      public static func == (a: MapboxNavigationCore.Session.State.ActiveGuidanceState, b: MapboxNavigationCore.Session.State.ActiveGuidanceState) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static func == (a: MapboxNavigationCore.Session.State, b: MapboxNavigationCore.Session.State) -> Swift.Bool
  }
  public static func == (a: MapboxNavigationCore.Session, b: MapboxNavigationCore.Session) -> Swift.Bool
}
public struct RouteProgressState : Swift.Sendable {
  public let routeProgress: MapboxNavigationCore.RouteProgress
}
public struct MapMatchingState : Swift.Equatable, @unchecked Swift.Sendable {
  public let location: CoreLocation.CLLocation
  public let mapMatchingResult: MapboxNavigationCore.MapMatchingResult
  public let speedLimit: MapboxNavigationCore.SpeedLimit
  public let currentSpeed: Foundation.Measurement<Foundation.UnitSpeed>
  public let roadName: MapboxNavigationCore.RoadName?
  public var enhancedLocation: CoreLocation.CLLocation {
    get
  }
  public static func == (a: MapboxNavigationCore.MapMatchingState, b: MapboxNavigationCore.MapMatchingState) -> Swift.Bool
}
public struct FallbackToTilesState : Swift.Equatable, Swift.Sendable {
  public let usingLatestTiles: Swift.Bool
  public static func == (a: MapboxNavigationCore.FallbackToTilesState, b: MapboxNavigationCore.FallbackToTilesState) -> Swift.Bool
}
public struct SpokenInstructionState : Swift.Equatable, Swift.Sendable {
  public let spokenInstruction: MapboxNavigationCore.SpokenInstruction
  public static func == (a: MapboxNavigationCore.SpokenInstructionState, b: MapboxNavigationCore.SpokenInstructionState) -> Swift.Bool
}
public struct VisualInstructionState : Swift.Equatable, Swift.Sendable {
  public let visualInstruction: MapboxNavigationCore.VisualInstructionBanner
  public static func == (a: MapboxNavigationCore.VisualInstructionState, b: MapboxNavigationCore.VisualInstructionState) -> Swift.Bool
}
public protocol WaypointArrivalEvent : MapboxNavigationCore.NavigationEvent {
}
public struct WaypointArrivalStatus : Swift.Equatable, Swift.Sendable {
  public static func == (lhs: MapboxNavigationCore.WaypointArrivalStatus, rhs: MapboxNavigationCore.WaypointArrivalStatus) -> Swift.Bool
  public let event: any MapboxNavigationCore.WaypointArrivalEvent
  public enum Events {
    public struct ToFinalDestination : MapboxNavigationCore.WaypointArrivalEvent, @unchecked Swift.Sendable {
      public let destination: MapboxNavigationCore.Waypoint
      public static func == (a: MapboxNavigationCore.WaypointArrivalStatus.Events.ToFinalDestination, b: MapboxNavigationCore.WaypointArrivalStatus.Events.ToFinalDestination) -> Swift.Bool
    }
    public struct ToWaypoint : MapboxNavigationCore.WaypointArrivalEvent, @unchecked Swift.Sendable {
      public let waypoint: MapboxNavigationCore.Waypoint
      public let legIndex: Swift.Int
      public static func == (a: MapboxNavigationCore.WaypointArrivalStatus.Events.ToWaypoint, b: MapboxNavigationCore.WaypointArrivalStatus.Events.ToWaypoint) -> Swift.Bool
    }
    public struct NextLegStarted : MapboxNavigationCore.WaypointArrivalEvent, @unchecked Swift.Sendable {
      public let newLegIndex: Swift.Int
      public static func == (a: MapboxNavigationCore.WaypointArrivalStatus.Events.NextLegStarted, b: MapboxNavigationCore.WaypointArrivalStatus.Events.NextLegStarted) -> Swift.Bool
    }
  }
}
public protocol ReroutingEvent : MapboxNavigationCore.NavigationEvent {
}
public struct ReroutingStatus : Swift.Equatable, Swift.Sendable {
  public static func == (lhs: MapboxNavigationCore.ReroutingStatus, rhs: MapboxNavigationCore.ReroutingStatus) -> Swift.Bool
  public let event: any MapboxNavigationCore.ReroutingEvent
  public enum Events {
    public struct FetchingRoute : MapboxNavigationCore.ReroutingEvent, Swift.Sendable {
      public static func == (a: MapboxNavigationCore.ReroutingStatus.Events.FetchingRoute, b: MapboxNavigationCore.ReroutingStatus.Events.FetchingRoute) -> Swift.Bool
    }
    public struct Interrupted : MapboxNavigationCore.ReroutingEvent, Swift.Sendable {
      public static func == (a: MapboxNavigationCore.ReroutingStatus.Events.Interrupted, b: MapboxNavigationCore.ReroutingStatus.Events.Interrupted) -> Swift.Bool
    }
    public struct Failed : MapboxNavigationCore.ReroutingEvent, Swift.Sendable {
      public let error: MapboxNavigationCore.DirectionsError
      public static func == (a: MapboxNavigationCore.ReroutingStatus.Events.Failed, b: MapboxNavigationCore.ReroutingStatus.Events.Failed) -> Swift.Bool
    }
    public struct Fetched : MapboxNavigationCore.ReroutingEvent, Swift.Sendable {
      public static func == (a: MapboxNavigationCore.ReroutingStatus.Events.Fetched, b: MapboxNavigationCore.ReroutingStatus.Events.Fetched) -> Swift.Bool
    }
  }
}
public protocol AlternativesEvent : MapboxNavigationCore.NavigationEvent {
}
public struct AlternativesStatus : Swift.Equatable, Swift.Sendable {
  public static func == (lhs: MapboxNavigationCore.AlternativesStatus, rhs: MapboxNavigationCore.AlternativesStatus) -> Swift.Bool
  public let event: any MapboxNavigationCore.AlternativesEvent
  public enum Events {
    public struct Updated : MapboxNavigationCore.AlternativesEvent, Swift.Sendable {
      public let actualAlternativeRoutes: [MapboxNavigationCore.AlternativeRoute]
      public static func == (a: MapboxNavigationCore.AlternativesStatus.Events.Updated, b: MapboxNavigationCore.AlternativesStatus.Events.Updated) -> Swift.Bool
    }
    public struct SwitchedToAlternative : MapboxNavigationCore.AlternativesEvent, Swift.Sendable {
      public let navigationRoutes: MapboxNavigationCore.NavigationRoutes
      public static func == (a: MapboxNavigationCore.AlternativesStatus.Events.SwitchedToAlternative, b: MapboxNavigationCore.AlternativesStatus.Events.SwitchedToAlternative) -> Swift.Bool
    }
  }
}
public protocol FasterRoutesEvent : MapboxNavigationCore.NavigationEvent {
}
public struct FasterRoutesStatus : Swift.Equatable, Swift.Sendable {
  public static func == (lhs: MapboxNavigationCore.FasterRoutesStatus, rhs: MapboxNavigationCore.FasterRoutesStatus) -> Swift.Bool
  public let event: any MapboxNavigationCore.FasterRoutesEvent
  public enum Events {
    public struct Detected : MapboxNavigationCore.FasterRoutesEvent, Swift.Sendable {
      public static func == (a: MapboxNavigationCore.FasterRoutesStatus.Events.Detected, b: MapboxNavigationCore.FasterRoutesStatus.Events.Detected) -> Swift.Bool
    }
    public struct Applied : MapboxNavigationCore.FasterRoutesEvent, Swift.Sendable {
      public static func == (a: MapboxNavigationCore.FasterRoutesStatus.Events.Applied, b: MapboxNavigationCore.FasterRoutesStatus.Events.Applied) -> Swift.Bool
    }
  }
}
public protocol RefreshingEvent : MapboxNavigationCore.NavigationEvent {
}
public struct RefreshingStatus : Swift.Equatable, Swift.Sendable {
  public static func == (lhs: MapboxNavigationCore.RefreshingStatus, rhs: MapboxNavigationCore.RefreshingStatus) -> Swift.Bool
  public let event: any MapboxNavigationCore.RefreshingEvent
  public enum Events {
    public struct Refreshing : MapboxNavigationCore.RefreshingEvent, Swift.Sendable {
      public static func == (a: MapboxNavigationCore.RefreshingStatus.Events.Refreshing, b: MapboxNavigationCore.RefreshingStatus.Events.Refreshing) -> Swift.Bool
    }
    public struct Refreshed : MapboxNavigationCore.RefreshingEvent, Swift.Sendable {
      public static func == (a: MapboxNavigationCore.RefreshingStatus.Events.Refreshed, b: MapboxNavigationCore.RefreshingStatus.Events.Refreshed) -> Swift.Bool
    }
    public struct Invalidated : MapboxNavigationCore.RefreshingEvent, Swift.Sendable {
      public let navigationRoutes: MapboxNavigationCore.NavigationRoutes
      public static func == (a: MapboxNavigationCore.RefreshingStatus.Events.Invalidated, b: MapboxNavigationCore.RefreshingStatus.Events.Invalidated) -> Swift.Bool
    }
  }
}
public protocol EHorizonEvent : MapboxNavigationCore.NavigationEvent {
}
public struct EHorizonStatus : Swift.Equatable, Swift.Sendable {
  public static func == (lhs: MapboxNavigationCore.EHorizonStatus, rhs: MapboxNavigationCore.EHorizonStatus) -> Swift.Bool
  public let event: any MapboxNavigationCore.EHorizonEvent
  public enum Events {
    public struct PositionUpdated : Swift.Sendable, MapboxNavigationCore.EHorizonEvent {
      public let position: MapboxNavigationCore.RoadGraph.Position
      public let startingEdge: MapboxNavigationCore.RoadGraph.Edge
      public let updatesMostProbablePath: Swift.Bool
      public let distances: [MapboxNavigationCore.DistancedRoadObject]
      public static func == (a: MapboxNavigationCore.EHorizonStatus.Events.PositionUpdated, b: MapboxNavigationCore.EHorizonStatus.Events.PositionUpdated) -> Swift.Bool
    }
    public struct RoadObjectEntered : Swift.Sendable, MapboxNavigationCore.EHorizonEvent {
      public let roadObjectId: MapboxNavigationCore.RoadObject.Identifier
      public let enteredFromStart: Swift.Bool
      public static func == (a: MapboxNavigationCore.EHorizonStatus.Events.RoadObjectEntered, b: MapboxNavigationCore.EHorizonStatus.Events.RoadObjectEntered) -> Swift.Bool
    }
    public struct RoadObjectExited : Swift.Sendable, MapboxNavigationCore.EHorizonEvent {
      public let roadObjectId: MapboxNavigationCore.RoadObject.Identifier
      public let exitedFromEnd: Swift.Bool
      public static func == (a: MapboxNavigationCore.EHorizonStatus.Events.RoadObjectExited, b: MapboxNavigationCore.EHorizonStatus.Events.RoadObjectExited) -> Swift.Bool
    }
    public struct RoadObjectPassed : Swift.Sendable, MapboxNavigationCore.EHorizonEvent {
      public let roadObjectId: MapboxNavigationCore.RoadObject.Identifier
      public static func == (a: MapboxNavigationCore.EHorizonStatus.Events.RoadObjectPassed, b: MapboxNavigationCore.EHorizonStatus.Events.RoadObjectPassed) -> Swift.Bool
    }
  }
}
public protocol NavigatorError : Swift.Error {
}
public enum NavigatorErrors {
  public struct FailedToSetRoute : MapboxNavigationCore.NavigatorError {
    public let underlyingError: (any Swift.Error)?
  }
  public struct FailedToSelectAlternativeRoute : MapboxNavigationCore.NavigatorError {
  }
  public struct FailedToUpdateAlternativeRoutes : MapboxNavigationCore.NavigatorError {
    public let localizedDescription: Swift.String
  }
  public struct FailedToSelectRouteLeg : MapboxNavigationCore.NavigatorError {
  }
  public struct FailedToSetToIdle : MapboxNavigationCore.NavigatorError {
  }
  public struct FailedToPause : MapboxNavigationCore.NavigatorError {
  }
  public struct UnexpectedNavigationStatus : MapboxNavigationCore.NavigatorError {
  }
  public struct InterruptedReroute : MapboxNavigationCore.NavigatorError {
    public let underlyingError: (any Swift.Error)?
  }
}
public struct RoadMatching : Swift.Sendable {
  public let roadGraph: MapboxNavigationCore.RoadGraph
  public let roadObjectStore: MapboxNavigationCore.RoadObjectStore
  public let roadObjectMatcher: MapboxNavigationCore.RoadObjectMatcher
}
public struct RoadInfo : Swift.Equatable, Swift.Sendable {
  public let countryCodeIso2: Swift.String?
  public let drivingSide: MapboxDirections.DrivingSide
  public let isOneWay: Swift.Bool
  public let laneCount: Swift.Int?
  public let roadClasses: MapboxNavigationCore.RoadClasses
  public init(countryCodeIso2: Swift.String?, drivingSide: MapboxDirections.DrivingSide, isOneWay: Swift.Bool, laneCount: Swift.Int?, roadClasses: MapboxNavigationCore.RoadClasses)
  public static func == (a: MapboxNavigationCore.RoadInfo, b: MapboxNavigationCore.RoadInfo) -> Swift.Bool
}
public struct RouteLegProgress : Swift.Equatable, Swift.Sendable {
  public var leg: MapboxNavigationCore.RouteLeg {
    get
  }
  public var distanceTraveled: Swift.Double {
    get
  }
  public var durationRemaining: Swift.Double {
    get
  }
  public var distanceRemaining: Swift.Double {
    get
  }
  public var fractionTraveled: Swift.Double {
    get
  }
  public var userHasArrivedAtWaypoint: Swift.Bool
  public var stepIndex: Swift.Int {
    get
  }
  public var remainingSteps: [MapboxNavigationCore.RouteStep] {
    get
  }
  public func stepBefore(_ step: MapboxNavigationCore.RouteStep) -> MapboxNavigationCore.RouteStep?
  public func stepAfter(_ step: MapboxNavigationCore.RouteStep) -> MapboxNavigationCore.RouteStep?
  public var priorStep: MapboxNavigationCore.RouteStep? {
    get
  }
  public var currentStep: MapboxNavigationCore.RouteStep {
    get
  }
  public var upcomingStep: MapboxNavigationCore.RouteStep? {
    get
  }
  public var followOnStep: MapboxNavigationCore.RouteStep? {
    get
  }
  public func isCurrentStep(_ step: MapboxNavigationCore.RouteStep) -> Swift.Bool
  public var currentStepProgress: MapboxNavigationCore.RouteStepProgress {
    get
  }
  public var currentSpeedLimit: Foundation.Measurement<Foundation.UnitSpeed>? {
    get
  }
  public var shapeIndex: Swift.Int {
    get
  }
  public init(leg: MapboxNavigationCore.RouteLeg)
  public static func == (a: MapboxNavigationCore.RouteLegProgress, b: MapboxNavigationCore.RouteLegProgress) -> Swift.Bool
}
public struct RouteProgress : Swift.Equatable, Swift.Sendable {
  public init(navigationRoutes: MapboxNavigationCore.NavigationRoutes, waypoints: [MapboxNavigationCore.Waypoint], congestionConfiguration: MapboxNavigationCore.CongestionRangesConfiguration = .default)
  public let waypoints: [MapboxNavigationCore.Waypoint]
  public var distanceTraveled: Swift.Double {
    get
  }
  public var durationRemaining: Swift.Double {
    get
  }
  public var fractionTraveled: Swift.Double {
    get
  }
  public var distanceRemaining: Swift.Double {
    get
  }
  public var remainingWaypoints: [MapboxNavigationCore.Waypoint] {
    get
  }
  public var upcomingRouteAlerts: [MapboxNavigationCore.RouteAlert] {
    get
  }
  public var nearbyShape: Turf.LineString {
    get
  }
  public var navigationRoutes: MapboxNavigationCore.NavigationRoutes {
    get
  }
  public var route: MapboxDirections.Route {
    get
  }
  public var routeId: MapboxNavigationCore.RouteId {
    get
  }
  public var shapeIndex: Swift.Int {
    get
  }
  public var legIndex: Swift.Int {
    get
  }
  public var currentLeg: MapboxNavigationCore.RouteLeg {
    get
  }
  public var remainingLegs: [MapboxNavigationCore.RouteLeg] {
    get
  }
  public var isFinalLeg: Swift.Bool {
    get
  }
  public var currentLegProgress: MapboxNavigationCore.RouteLegProgress
  public var priorLeg: MapboxNavigationCore.RouteLeg? {
    get
  }
  public var upcomingLeg: MapboxNavigationCore.RouteLeg? {
    get
  }
  public var remainingSteps: [MapboxNavigationCore.RouteStep] {
    get
  }
  public var priorStep: MapboxNavigationCore.RouteStep? {
    get
  }
  public var upcomingStep: MapboxNavigationCore.RouteStep? {
    get
  }
  public struct TimedCongestionLevel : Swift.Equatable, Swift.Sendable {
    public var level: MapboxNavigationCore.CongestionLevel
    public var timeInterval: Foundation.TimeInterval
    public static func == (a: MapboxNavigationCore.RouteProgress.TimedCongestionLevel, b: MapboxNavigationCore.RouteProgress.TimedCongestionLevel) -> Swift.Bool
  }
  public var congestionTravelTimesSegmentsByStep: [[[MapboxNavigationCore.RouteProgress.TimedCongestionLevel]]] {
    get
  }
  public var congestionTimesPerStep: [[[MapboxNavigationCore.CongestionLevel : Foundation.TimeInterval]]] {
    get
  }
  public var averageCongestionLevelRemainingOnLeg: MapboxNavigationCore.CongestionLevel? {
    get
  }
  public var routeIsComplete: Swift.Bool {
    get
  }
  public static func == (a: MapboxNavigationCore.RouteProgress, b: MapboxNavigationCore.RouteProgress) -> Swift.Bool
}
extension MapboxNavigationNative.UpcomingRouteAlert : @unchecked Swift.Sendable {
}
public struct RouteStepProgress : Swift.Equatable, Swift.Sendable {
  public init(step: MapboxNavigationCore.RouteStep)
  public var step: MapboxNavigationCore.RouteStep {
    get
  }
  public var distanceTraveled: Swift.Double {
    get
  }
  public var distanceRemaining: Swift.Double {
    get
  }
  public var fractionTraveled: Swift.Double {
    get
  }
  public var durationRemaining: Swift.Double {
    get
  }
  public func remainingStepCoordinates() -> [CoreLocation.CLLocationCoordinate2D]
  public var intersectionsIncludingUpcomingManeuverIntersection: [MapboxDirections.Intersection]?
  public var upcomingIntersection: MapboxDirections.Intersection? {
    get
  }
  public var intersectionIndex: Swift.Int {
    get
  }
  public var currentIntersection: MapboxDirections.Intersection? {
    get
  }
  public var userDistanceToUpcomingIntersection: CoreLocation.CLLocationDistance?
  public var visualInstructionIndex: Swift.Int {
    get
  }
  public var remainingVisualInstructions: [MapboxNavigationCore.VisualInstructionBanner]? {
    get
  }
  public var spokenInstructionIndex: Swift.Int? {
    get
  }
  public var remainingSpokenInstructions: [MapboxNavigationCore.SpokenInstruction]? {
    get
  }
  public var currentSpokenInstruction: MapboxNavigationCore.SpokenInstruction? {
    get
  }
  public var currentVisualInstruction: MapboxNavigationCore.VisualInstructionBanner? {
    get
  }
  public var keyPathsAffectingValueForRemainingVisualInstructions: Swift.Set<Swift.String> {
    get
  }
  public var keyPathsAffectingValueForRemainingSpokenInstructions: Swift.Set<Swift.String> {
    get
  }
  public static func == (a: MapboxNavigationCore.RouteStepProgress, b: MapboxNavigationCore.RouteStepProgress) -> Swift.Bool
}
public struct SpeedLimit : Swift.Equatable, @unchecked Swift.Sendable {
  public let value: Foundation.Measurement<Foundation.UnitSpeed>?
  public let signStandard: MapboxDirections.SignStandard
  public static func == (a: MapboxNavigationCore.SpeedLimit, b: MapboxNavigationCore.SpeedLimit) -> Swift.Bool
}
public struct Tunnel : Swift.Equatable {
  public let name: Swift.String?
  public static func == (a: MapboxNavigationCore.Tunnel, b: MapboxNavigationCore.Tunnel) -> Swift.Bool
}
public struct PredictiveCacheConfig : Swift.Equatable, Swift.Sendable {
  public var predictiveCacheNavigationConfig: MapboxNavigationCore.PredictiveCacheNavigationConfig
  public var predictiveCacheMapsConfig: MapboxNavigationCore.PredictiveCacheMapsConfig
  public var predictiveCacheSearchConfig: MapboxNavigationCore.PredictiveCacheSearchConfig?
  public init(predictiveCacheNavigationConfig: MapboxNavigationCore.PredictiveCacheNavigationConfig = .init(), predictiveCacheMapsConfig: MapboxNavigationCore.PredictiveCacheMapsConfig = .init(), predictiveCacheSearchConfig: MapboxNavigationCore.PredictiveCacheSearchConfig? = nil)
  public static func == (a: MapboxNavigationCore.PredictiveCacheConfig, b: MapboxNavigationCore.PredictiveCacheConfig) -> Swift.Bool
}
public struct PredictiveCacheLocationConfig : Swift.Equatable, Swift.Sendable {
  public var currentLocationRadius: Swift.Double
  public var routeBufferRadius: Swift.Double
  public var destinationLocationRadius: Swift.Double
  public init(currentLocationRadius: CoreLocation.CLLocationDistance = 2000, routeBufferRadius: CoreLocation.CLLocationDistance = 500, destinationLocationRadius: CoreLocation.CLLocationDistance = 5000)
  public static func == (a: MapboxNavigationCore.PredictiveCacheLocationConfig, b: MapboxNavigationCore.PredictiveCacheLocationConfig) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class PredictiveCacheManager {
  @_Concurrency.MainActor public func updateMapControllers(mapView: MapboxMaps.MapView)
  @objc deinit
}
extension MapboxCommon.TilesetDescriptor : @unchecked Swift.Sendable {
}
extension MapboxNavigationCore.PredictiveCacheManager : @unchecked Swift.Sendable {
}
public struct PredictiveCacheMapsConfig : Swift.Equatable, Swift.Sendable {
  public var locationConfig: MapboxNavigationCore.PredictiveCacheLocationConfig
  public var maximumConcurrentRequests: Swift.UInt32
  public var zoomRange: Swift.ClosedRange<Swift.UInt8>
  public init(locationConfig: MapboxNavigationCore.PredictiveCacheLocationConfig = .init(), maximumConcurrentRequests: Swift.UInt32 = 2, zoomRange: Swift.ClosedRange<Swift.UInt8> = 0...16)
  public static func == (a: MapboxNavigationCore.PredictiveCacheMapsConfig, b: MapboxNavigationCore.PredictiveCacheMapsConfig) -> Swift.Bool
}
public struct PredictiveCacheNavigationConfig : Swift.Equatable, Swift.Sendable {
  public var locationConfig: MapboxNavigationCore.PredictiveCacheLocationConfig
  public init(locationConfig: MapboxNavigationCore.PredictiveCacheLocationConfig = .init())
  public static func == (a: MapboxNavigationCore.PredictiveCacheNavigationConfig, b: MapboxNavigationCore.PredictiveCacheNavigationConfig) -> Swift.Bool
}
public struct PredictiveCacheSearchConfig : Swift.Equatable, Swift.Sendable {
  public var locationConfig: MapboxNavigationCore.PredictiveCacheLocationConfig
  public var searchTilesetDescriptor: MapboxCommon.TilesetDescriptor
  public init(locationConfig: MapboxNavigationCore.PredictiveCacheLocationConfig = .init(), searchTilesetDescriptor: MapboxCommon.TilesetDescriptor)
  public static func == (a: MapboxNavigationCore.PredictiveCacheSearchConfig, b: MapboxNavigationCore.PredictiveCacheSearchConfig) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class MapboxRoutingProvider : MapboxNavigationCore.RoutingProvider, @unchecked Swift.Sendable {
  final public func calculateRoutes(options: MapboxDirections.RouteOptions) -> MapboxNavigationCore.MapboxRoutingProvider.FetchTask
  final public func calculateRoutes(options: MapboxDirections.MatchOptions) -> MapboxNavigationCore.MapboxRoutingProvider.FetchTask
  @objc deinit
}
@_inheritsConvenienceInitializers open class NavigationRouteOptions : MapboxDirections.RouteOptions, @unchecked Swift.Sendable {
  public var distanceUnit: Foundation.LengthFormatter.Unit
  convenience public init(waypoints: [MapboxNavigationCore.Waypoint], profileIdentifier: MapboxNavigationCore.ProfileIdentifier? = .automobileAvoidingTraffic, queryItems: [Foundation.URLQueryItem]? = nil, locale: Foundation.Locale, distanceUnit: Foundation.LengthFormatter.Unit)
  required public init(waypoints: [MapboxNavigationCore.Waypoint], profileIdentifier: MapboxNavigationCore.ProfileIdentifier? = .automobileAvoidingTraffic, queryItems: [Foundation.URLQueryItem]? = nil)
  convenience public init(navigationMatchOptions options: MapboxNavigationCore.NavigationMatchOptions)
  convenience public init(locations: [CoreLocation.CLLocation], profileIdentifier: MapboxNavigationCore.ProfileIdentifier? = .automobileAvoidingTraffic, queryItems: [Foundation.URLQueryItem]? = nil)
  convenience public init(coordinates: [CoreLocation.CLLocationCoordinate2D], profileIdentifier: MapboxNavigationCore.ProfileIdentifier? = .automobileAvoidingTraffic, queryItems: [Foundation.URLQueryItem]? = nil)
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
}
@_inheritsConvenienceInitializers open class NavigationMatchOptions : MapboxDirections.MatchOptions, @unchecked Swift.Sendable {
  public var distanceUnit: Foundation.LengthFormatter.Unit
  convenience public init(waypoints: [MapboxNavigationCore.Waypoint], profileIdentifier: MapboxNavigationCore.ProfileIdentifier? = .automobileAvoidingTraffic, queryItems: [Foundation.URLQueryItem]? = nil, distanceUnit: Foundation.LengthFormatter.Unit)
  required public init(waypoints: [MapboxNavigationCore.Waypoint], profileIdentifier: MapboxNavigationCore.ProfileIdentifier? = .automobileAvoidingTraffic, queryItems: [Foundation.URLQueryItem]? = nil)
  convenience public init(locations: [CoreLocation.CLLocation], profileIdentifier: MapboxNavigationCore.ProfileIdentifier? = .automobileAvoidingTraffic, queryItems: [Foundation.URLQueryItem]? = nil)
  convenience public init(coordinates: [CoreLocation.CLLocationCoordinate2D], profileIdentifier: MapboxNavigationCore.ProfileIdentifier? = .automobileAvoidingTraffic, queryItems: [Foundation.URLQueryItem]? = nil)
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
}
public protocol RoutingProvider : Swift.Sendable {
  typealias FetchTask = _Concurrency.Task<MapboxNavigationCore.NavigationRoutes, any Swift.Error>
  func calculateRoutes(options: MapboxDirections.RouteOptions) -> Self.FetchTask
  func calculateRoutes(options: MapboxDirections.MatchOptions) -> Self.FetchTask
}
public enum RoutingProviderSource : Swift.Equatable, Swift.Sendable {
  case online
  case offline
  case hybrid
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxNavigationCore.RoutingProviderSource, b: MapboxNavigationCore.RoutingProviderSource) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SdkInfo : Swift.Sendable {
  public static let navigationUX: MapboxNavigationCore.SdkInfo
  public static let navigationCore: MapboxNavigationCore.SdkInfo
  public let name: Swift.String
  public let version: Swift.String
  public let packageName: Swift.String
}
public struct AlternativeRoutesDetectionConfig : Swift.Equatable, Swift.Sendable {
  public struct AcceptionPolicy : Swift.OptionSet, Swift.Sendable {
    public typealias RawValue = Swift.UInt
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let unfiltered: MapboxNavigationCore.AlternativeRoutesDetectionConfig.AcceptionPolicy
    public static let fasterRoutes: MapboxNavigationCore.AlternativeRoutesDetectionConfig.AcceptionPolicy
    public static let shorterRoutes: MapboxNavigationCore.AlternativeRoutesDetectionConfig.AcceptionPolicy
    public typealias ArrayLiteralElement = MapboxNavigationCore.AlternativeRoutesDetectionConfig.AcceptionPolicy
    public typealias Element = MapboxNavigationCore.AlternativeRoutesDetectionConfig.AcceptionPolicy
  }
  @available(*, deprecated, message: "This feature no longer has any effect.")
  public var refreshesAfterPassingDeviation: Swift.Bool
  @available(*, deprecated, message: "This feature no longer has any effect other then setting the refresh interval. Use 'refreshIntervalSeconds' instead to configure the refresh interval directly.")
  public var refreshesWhenNoAvailableAlternatives: MapboxNavigationCore.AlternativeRoutesDetectionConfig.RefreshOnEmpty {
    get
    set
  }
  @available(*, deprecated, message: "This feature no longer has any effect.")
  public enum RefreshOnEmpty : Swift.Equatable, Swift.Sendable {
    case noPeriodicRefresh
    case refreshesPeriodically(_: Foundation.TimeInterval = AlternativeRoutesDetectionConfig.defaultRefreshIntervalSeconds)
    public static func == (a: MapboxNavigationCore.AlternativeRoutesDetectionConfig.RefreshOnEmpty, b: MapboxNavigationCore.AlternativeRoutesDetectionConfig.RefreshOnEmpty) -> Swift.Bool
  }
  public var acceptionPolicy: MapboxNavigationCore.AlternativeRoutesDetectionConfig.AcceptionPolicy
  public var refreshIntervalSeconds: Foundation.TimeInterval
  @available(*, deprecated, message: "Use 'init(acceptionPolicy:refreshIntervalSeconds:)' instead.")
  public init(refreshesAfterPassingDeviation: Swift.Bool = true, refreshesWhenNoAvailableAlternatives: MapboxNavigationCore.AlternativeRoutesDetectionConfig.RefreshOnEmpty = .noPeriodicRefresh, acceptionPolicy: MapboxNavigationCore.AlternativeRoutesDetectionConfig.AcceptionPolicy = .unfiltered)
  public init(acceptionPolicy: MapboxNavigationCore.AlternativeRoutesDetectionConfig.AcceptionPolicy = .unfiltered, refreshIntervalSeconds: Foundation.TimeInterval = Self.defaultRefreshIntervalSeconds)
  public static let defaultRefreshIntervalSeconds: Swift.Double
  public static func == (a: MapboxNavigationCore.AlternativeRoutesDetectionConfig, b: MapboxNavigationCore.AlternativeRoutesDetectionConfig) -> Swift.Bool
}
public struct CoreConfig : Swift.Equatable {
  public struct MultiLegAdvanceContext : Swift.Sendable, Swift.Equatable {
    public let arrivedLegIndex: Swift.Int
    public static func == (a: MapboxNavigationCore.CoreConfig.MultiLegAdvanceContext, b: MapboxNavigationCore.CoreConfig.MultiLegAdvanceContext) -> Swift.Bool
  }
  public typealias MultilegAdvanceMode = MapboxNavigationCore.ApprovalModeAsync<MapboxNavigationCore.CoreConfig.MultiLegAdvanceContext>
  public let credentials: MapboxNavigationCore.NavigationCoreApiConfiguration
  public var routeRequestConfig: MapboxNavigationCore.CoreConfig.RouteRequestConfig
  public var routingConfig: MapboxNavigationCore.RoutingConfig
  public let telemetryAppMetadata: MapboxNavigationCore.TelemetryAppMetadata?
  public var locationSource: MapboxNavigationCore.LocationSource
  public var logLevel: MapboxCommon.LoggingLevel
  public let copilotEnabled: Swift.Bool
  public var unitOfMeasurement: MapboxNavigationCore.UnitOfMeasurement
  public var locale: Foundation.Locale
  public let disableBackgroundTrackingLocation: Swift.Bool
  public let utilizeSensorData: Swift.Bool
  public let navigatorPredictionInterval: Foundation.TimeInterval?
  public var congestionConfig: MapboxNavigationCore.CongestionRangesConfiguration
  public let historyRecordingConfig: MapboxNavigationCore.HistoryRecordingConfig?
  public var predictiveCacheConfig: MapboxNavigationCore.PredictiveCacheConfig?
  public var electronicHorizonConfig: MapboxNavigationCore.ElectronicHorizonConfig?
  public let liveIncidentsConfig: MapboxNavigationCore.IncidentsConfig?
  public var multilegAdvancing: MapboxNavigationCore.CoreConfig.MultilegAdvanceMode
  public let tilesVersion: Swift.String
  public let tilestoreConfig: MapboxNavigationCore.TileStoreConfiguration
  public var ttsConfig: MapboxNavigationCore.TTSConfig
  public struct RouteRequestConfig : Swift.Equatable, Swift.Sendable {
    public let profileIdentifier: MapboxNavigationCore.ProfileIdentifier
    public var roadClassesToAvoid: MapboxNavigationCore.RoadClasses
    public var roadClassesToAllow: MapboxNavigationCore.RoadClasses
    public var allowsUTurnAtWaypoint: Swift.Bool
    public var customQueryParameters: [Foundation.URLQueryItem]?
    public init(profileIdentifier: MapboxNavigationCore.ProfileIdentifier = .automobileAvoidingTraffic, roadClassesToAvoid: MapboxNavigationCore.RoadClasses = [], roadClassesToAllow: MapboxNavigationCore.RoadClasses = [], allowsUTurnAtWaypoint: Swift.Bool = false, customQueryParameters: [Foundation.URLQueryItem]? = nil)
    public static func == (a: MapboxNavigationCore.CoreConfig.RouteRequestConfig, b: MapboxNavigationCore.CoreConfig.RouteRequestConfig) -> Swift.Bool
  }
  public init(credentials: MapboxNavigationCore.NavigationCoreApiConfiguration = .init(), routeRequestConfig: MapboxNavigationCore.CoreConfig.RouteRequestConfig = .init(), routingConfig: MapboxNavigationCore.RoutingConfig = .init(), telemetryAppMetadata: MapboxNavigationCore.TelemetryAppMetadata? = nil, logLevel: MapboxCommon.LoggingLevel = .warning, locationSource: MapboxNavigationCore.LocationSource = .live, copilotEnabled: Swift.Bool = false, unitOfMeasurement: MapboxNavigationCore.UnitOfMeasurement = .auto, locale: Foundation.Locale = .nationalizedCurrent, disableBackgroundTrackingLocation: Swift.Bool = true, utilizeSensorData: Swift.Bool = false, navigatorPredictionInterval: Foundation.TimeInterval? = nil, congestionConfig: MapboxNavigationCore.CongestionRangesConfiguration = .default, historyRecordingConfig: MapboxNavigationCore.HistoryRecordingConfig? = nil, predictiveCacheConfig: MapboxNavigationCore.PredictiveCacheConfig? = PredictiveCacheConfig(), electronicHorizonConfig: MapboxNavigationCore.ElectronicHorizonConfig? = nil, liveIncidentsConfig: MapboxNavigationCore.IncidentsConfig? = nil, multilegAdvancing: MapboxNavigationCore.CoreConfig.MultilegAdvanceMode = .automatically, tilesVersion: Swift.String = "", tilestoreConfig: MapboxNavigationCore.TileStoreConfiguration = .default, ttsConfig: MapboxNavigationCore.TTSConfig = .default)
  public static func == (a: MapboxNavigationCore.CoreConfig, b: MapboxNavigationCore.CoreConfig) -> Swift.Bool
}
public enum UnitOfMeasurement : Swift.Equatable, Swift.Sendable {
  case auto
  case imperial
  case metric
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxNavigationCore.UnitOfMeasurement, b: MapboxNavigationCore.UnitOfMeasurement) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct FasterRouteDetectionConfig : Swift.Equatable {
  public static func == (lhs: MapboxNavigationCore.FasterRouteDetectionConfig, rhs: MapboxNavigationCore.FasterRouteDetectionConfig) -> Swift.Bool
  public typealias FasterRouteApproval = MapboxNavigationCore.ApprovalModeAsync<(CoreLocation.CLLocation, MapboxNavigationCore.NavigationRoute)>
  public var fasterRouteApproval: MapboxNavigationCore.FasterRouteDetectionConfig.FasterRouteApproval
  public var proactiveReroutingInterval: Foundation.TimeInterval
  public var minimumRouteDurationRemaining: Foundation.TimeInterval
  public var minimumManeuverOffset: Foundation.TimeInterval
  public var customFasterRouteProvider: (any MapboxNavigationCore.FasterRouteProvider)?
  public init(fasterRouteApproval: MapboxNavigationCore.FasterRouteDetectionConfig.FasterRouteApproval = .automatically, proactiveReroutingInterval: Foundation.TimeInterval = 120, minimumRouteDurationRemaining: Foundation.TimeInterval = 600, minimumManeuverOffset: Foundation.TimeInterval = 70, customFasterRouteProvider: (any MapboxNavigationCore.FasterRouteProvider)? = nil)
}
public struct HistoryRecordingConfig : Swift.Equatable, Swift.Sendable {
  public static let defaultFolderName: Swift.String
  public var historyDirectoryURL: Foundation.URL
  public init(historyDirectoryURL: Foundation.URL = FileManager.default.urls(
            for: .documentDirectory,
            in: .userDomainMask
        )[0].appendingPathComponent(defaultFolderName))
  public static func == (a: MapboxNavigationCore.HistoryRecordingConfig, b: MapboxNavigationCore.HistoryRecordingConfig) -> Swift.Bool
}
public struct IncidentsConfig : Swift.Equatable, Swift.Sendable {
  public var graph: Swift.String
  public var apiURL: Foundation.URL?
  public init(graph: Swift.String, apiURL: Foundation.URL?)
  public static func == (a: MapboxNavigationCore.IncidentsConfig, b: MapboxNavigationCore.IncidentsConfig) -> Swift.Bool
}
public struct NavigationCoreApiConfiguration : Swift.Equatable, Swift.Sendable {
  public let navigation: MapboxNavigationCore.ApiConfiguration
  public let map: MapboxNavigationCore.ApiConfiguration
  public let speech: MapboxNavigationCore.ApiConfiguration
  public init(navigation: MapboxNavigationCore.ApiConfiguration = .default, map: MapboxNavigationCore.ApiConfiguration = .default, speech: MapboxNavigationCore.ApiConfiguration = .default)
  public static func == (a: MapboxNavigationCore.NavigationCoreApiConfiguration, b: MapboxNavigationCore.NavigationCoreApiConfiguration) -> Swift.Bool
}
extension MapboxNavigationCore.NavigationCoreApiConfiguration {
  public init(accessToken: Swift.String)
}
public struct RerouteConfig : Swift.Equatable {
  public typealias OptionsCustomization = MapboxNavigationCore.EquatableClosure<MapboxDirections.RouteOptions, MapboxDirections.RouteOptions>
  @available(*, deprecated, message: "Use urlOptionsCustomization instead. Using optionsCustomization may lead to losing custom query items at reroutes.")
  public var optionsCustomization: MapboxNavigationCore.RerouteConfig.OptionsCustomization?
  public var detectsReroute: Swift.Bool
  public typealias UrlOptionsCustomization = MapboxNavigationCore.EquatableClosure<Swift.String, Swift.String>
  public var urlOptionsCustomization: MapboxNavigationCore.RerouteConfig.UrlOptionsCustomization?
  @available(*, deprecated, message: "Use init(detectsReroute:urlOptionsCustomization:) instead. Using optionsCustomization may lead to losing custom\nquery items at reroutes.")
  public init(detectsReroute: Swift.Bool = true, optionsCustomization: MapboxNavigationCore.RerouteConfig.OptionsCustomization? = nil)
  public init(detectsReroute: Swift.Bool = true, urlOptionsCustomization: MapboxNavigationCore.RerouteConfig.UrlOptionsCustomization? = nil)
  public init(detectsReroute: Swift.Bool = true)
  public static func == (a: MapboxNavigationCore.RerouteConfig, b: MapboxNavigationCore.RerouteConfig) -> Swift.Bool
}
public struct RoutingConfig : Swift.Equatable {
  public var alternativeRoutesDetectionConfig: MapboxNavigationCore.AlternativeRoutesDetectionConfig?
  public var fasterRouteDetectionConfig: MapboxNavigationCore.FasterRouteDetectionConfig?
  public var rerouteConfig: MapboxNavigationCore.RerouteConfig
  public var initialManeuverAvoidanceRadius: Foundation.TimeInterval
  public var routeRefreshPeriod: Foundation.TimeInterval?
  public var routingProviderSource: MapboxNavigationCore.RoutingProviderSource
  public var prefersOnlineRoute: Swift.Bool
  @available(*, deprecated, message: "Use 'init(alternativeRoutesDetectionConfig:fasterRouteDetectionConfig:rerouteConfig:initialManeuverAvoidanceRadius:routeRefreshPeriod:routingProviderSource:prefersOnlineRoute:)' instead.")
  public init(alternativeRoutesDetectionSettings: MapboxNavigationCore.AlternativeRoutesDetectionConfig? = .init(), fasterRouteDetectionSettings: MapboxNavigationCore.FasterRouteDetectionConfig? = .init(), rerouteSettings: MapboxNavigationCore.RerouteConfig = .init(), initialManeuverAvoidanceRadius: Foundation.TimeInterval = 8, routeRefreshPeriod: Foundation.TimeInterval? = 120, routingProviderSource: MapboxNavigationCore.RoutingProviderSource = .hybrid, prefersOnlineRoute: Swift.Bool = true, detectsReroute: Swift.Bool = true)
  public init(alternativeRoutesDetectionConfig: MapboxNavigationCore.AlternativeRoutesDetectionConfig? = .init(), fasterRouteDetectionConfig: MapboxNavigationCore.FasterRouteDetectionConfig? = .init(), rerouteConfig: MapboxNavigationCore.RerouteConfig = .init(), initialManeuverAvoidanceRadius: Foundation.TimeInterval = 8, routeRefreshPeriod: Foundation.TimeInterval? = 120, routingProviderSource: MapboxNavigationCore.RoutingProviderSource = .hybrid, prefersOnlineRoute: Swift.Bool = true)
  public static func == (a: MapboxNavigationCore.RoutingConfig, b: MapboxNavigationCore.RoutingConfig) -> Swift.Bool
}
public enum ApprovalMode<Context> : Swift.Equatable, Swift.Sendable {
  case automatically
  case manually
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxNavigationCore.ApprovalMode<Context>, b: MapboxNavigationCore.ApprovalMode<Context>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum ApprovalModeAsync<Context> : Swift.Equatable, Swift.Sendable where Context : Swift.Sendable {
  public static func == (lhs: MapboxNavigationCore.ApprovalModeAsync<Context>, rhs: MapboxNavigationCore.ApprovalModeAsync<Context>) -> Swift.Bool
  public typealias ApprovalCheck = @Sendable (Context) async -> Swift.Bool
  case automatically
  case manually(MapboxNavigationCore.ApprovalModeAsync<Context>.ApprovalCheck)
}
public struct EquatableClosure<Input, Output> : Swift.Equatable {
  public static func == (lhs: MapboxNavigationCore.EquatableClosure<Input, Output>, rhs: MapboxNavigationCore.EquatableClosure<Input, Output>) -> Swift.Bool
  public typealias Closure = (Input) -> Output
  public init(_ closure: MapboxNavigationCore.EquatableClosure<Input, Output>.Closure? = nil)
}
public struct StatusUpdatingSettings {
  public var updatingPatience: Foundation.TimeInterval?
  public var updatingInterval: Foundation.TimeInterval?
  public init(updatingPatience: Foundation.TimeInterval? = nil, updatingInterval: Foundation.TimeInterval? = nil)
}
public enum TTSConfig : Swift.Equatable, Swift.Sendable {
  public static func == (lhs: MapboxNavigationCore.TTSConfig, rhs: MapboxNavigationCore.TTSConfig) -> Swift.Bool
  case `default`
  case localOnly
  case custom(speechSynthesizer: any MapboxNavigationCore.SpeechSynthesizing)
}
public struct TelemetryAppMetadata : Swift.Equatable, Swift.Sendable {
  public let name: Swift.String
  public let version: Swift.String
  public var userId: Swift.String?
  public var sessionId: Swift.String?
  public init(name: Swift.String, version: Swift.String, userId: Swift.String?, sessionId: Swift.String?)
  public static func == (a: MapboxNavigationCore.TelemetryAppMetadata, b: MapboxNavigationCore.TelemetryAppMetadata) -> Swift.Bool
}
public struct TileStoreConfiguration : Swift.Equatable, Swift.Sendable {
  public enum Location : Swift.Equatable, Swift.Sendable {
    case `default`
    case custom(Foundation.URL)
    public var tileStoreURL: Foundation.URL? {
      get
    }
    public var tileStore: MapboxCommon.TileStore {
      get
    }
    public static func == (a: MapboxNavigationCore.TileStoreConfiguration.Location, b: MapboxNavigationCore.TileStoreConfiguration.Location) -> Swift.Bool
  }
  public let navigatorLocation: MapboxNavigationCore.TileStoreConfiguration.Location
  public let mapLocation: MapboxNavigationCore.TileStoreConfiguration.Location?
  public static var `default`: MapboxNavigationCore.TileStoreConfiguration {
    get
  }
  public static func custom(_ url: Foundation.URL) -> MapboxNavigationCore.TileStoreConfiguration
  public static func isolated(navigationLocation: MapboxNavigationCore.TileStoreConfiguration.Location, mapLocation: MapboxNavigationCore.TileStoreConfiguration.Location?) -> MapboxNavigationCore.TileStoreConfiguration
  public static func == (a: MapboxNavigationCore.TileStoreConfiguration, b: MapboxNavigationCore.TileStoreConfiguration) -> Swift.Bool
}
extension Network.NWPathMonitor : @unchecked Swift.Sendable {
}
extension MapboxNavigationNative.EventsMetadata : @unchecked Swift.Sendable {
}
extension MapboxNavigationNative.ScreenshotFormat : @unchecked Swift.Sendable {
}
public struct UserFeedback : @unchecked Swift.Sendable {
  public let description: Swift.String?
  public let type: any MapboxNavigationCore.FeedbackType
  public let source: MapboxNavigationCore.FeedbackSource
  public let screenshot: Swift.String?
  public let location: CoreLocation.CLLocation
}
public typealias ProfileIdentifier = MapboxDirections.ProfileIdentifier
public typealias Waypoint = MapboxDirections.Waypoint
public typealias CongestionLevel = MapboxDirections.CongestionLevel
public typealias RoadClasses = MapboxDirections.RoadClasses
public typealias SpokenInstruction = MapboxDirections.SpokenInstruction
public typealias VisualInstructionBanner = MapboxDirections.VisualInstructionBanner
public typealias DirectionsError = MapboxDirections.DirectionsError
public typealias RouteLeg = MapboxDirections.RouteLeg
public typealias RouteStep = MapboxDirections.RouteStep
@_documentation(visibility: internal) public typealias Log = MapboxNavigationCore.NavigationLog
@_documentation(visibility: internal) public enum NavigationLog {
  public typealias Category = MapboxNavigationCore.NavigationLogCategory
  public static func debug(_ message: Swift.String, category: MapboxNavigationCore.NavigationLog.Category)
  public static func info(_ message: Swift.String, category: MapboxNavigationCore.NavigationLog.Category)
  public static func warning(_ message: Swift.String, category: MapboxNavigationCore.NavigationLog.Category)
  public static func error(_ message: Swift.String, category: MapboxNavigationCore.NavigationLog.Category)
  public static func fault(_ message: Swift.String, category: MapboxNavigationCore.NavigationLog.Category)
  @available(*, unavailable, message: "Use NavigationLog.debug(_:category:)")
  public static func trace(_ message: Swift.String)
}
@_documentation(visibility: internal) public struct NavigationLogCategory : Swift.RawRepresentable, Swift.Sendable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let billing: MapboxNavigationCore.NavigationLogCategory
  public static let navigation: MapboxNavigationCore.NavigationLogCategory
  public static let settings: MapboxNavigationCore.NavigationLogCategory
  public static let unimplementedMethods: MapboxNavigationCore.NavigationLogCategory
  public static let navigationUI: MapboxNavigationCore.NavigationLogCategory
  public static let carPlay: MapboxNavigationCore.NavigationLogCategory
  public static let copilot: MapboxNavigationCore.NavigationLogCategory
  public static let audio: MapboxNavigationCore.NavigationLogCategory
  public var rawLogCategory: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension UIKit.UIWindow {
  @_Concurrency.MainActor @preconcurrency public func capture() -> UIKit.UIImage?
}
public protocol UnimplementedLogging {
  func logUnimplemented(protocolType: Any, level: os.OSLogType, function: Swift.String)
}
extension MapboxNavigationCore.UnimplementedLogging {
  public func logUnimplemented(protocolType: Any, level: os.OSLogType, function: Swift.String = #function)
}
extension Foundation.URLRequest {
  public mutating func setNavigationUXUserAgent()
}
extension Swift.String {
  public static let navigationUXUserAgent: Swift.String
  public static let navigationUXUserAgentFragment: Swift.String
}
extension Foundation.Bundle {
  public static let navigationUXName: Swift.String
  public static let navigationUIKitName: Swift.String
  public static let navigationCoreName: Swift.String
  public static var resolvedNavigationSDKName: Swift.String {
    get
  }
}
extension Foundation.Bundle {
  public static let mapboxNavigationVersion: Swift.String
  public static let mapboxNavigationUXBundleIdentifier: Swift.String
}
@_hasMissingDesignatedInitializers @_Concurrency.MainActor final public class MapboxSpeechSynthesizer : MapboxNavigationCore.SpeechSynthesizing {
  @_Concurrency.MainActor final public var voiceInstructions: Combine.AnyPublisher<any MapboxNavigationCore.VoiceInstructionEvent, Swift.Never> {
    get
  }
  @_Concurrency.MainActor final public var muted: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor final public var volume: MapboxNavigationCore.VolumeMode {
    get
    set
  }
  @_Concurrency.MainActor final public var locale: Foundation.Locale?
  @_Concurrency.MainActor final public var stepsAheadToCache: Swift.UInt
  @_Concurrency.MainActor final public var managesAudioSession: Swift.Bool
  @_Concurrency.MainActor final public var isSpeaking: Swift.Bool {
    get
  }
  @objc deinit
  @_Concurrency.MainActor final public func prepareIncomingSpokenInstructions(_ instructions: [MapboxNavigationCore.SpokenInstruction], locale: Foundation.Locale? = nil)
  @_Concurrency.MainActor final public func speak(_ instruction: MapboxNavigationCore.SpokenInstruction, during _: MapboxNavigationCore.RouteLegProgress, locale: Foundation.Locale? = nil)
  @_Concurrency.MainActor final public func stopSpeaking()
  @_Concurrency.MainActor final public func interruptSpeaking()
  @_Concurrency.MainActor final public func speak(_ instruction: MapboxNavigationCore.SpokenInstruction, data: Foundation.Data)
}
@_Concurrency.MainActor final public class MultiplexedSpeechSynthesizer : MapboxNavigationCore.SpeechSynthesizing {
  @_Concurrency.MainActor final public var voiceInstructions: Combine.AnyPublisher<any MapboxNavigationCore.VoiceInstructionEvent, Swift.Never> {
    get
  }
  @_Concurrency.MainActor final public var muted: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor final public var volume: MapboxNavigationCore.VolumeMode {
    get
    set
  }
  @_Concurrency.MainActor final public var locale: Foundation.Locale? {
    get
    set
  }
  @_Concurrency.MainActor final public var managesAudioSession: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor final public var isSpeaking: Swift.Bool {
    get
  }
  @_Concurrency.MainActor final public var speechSynthesizers: [any MapboxNavigationCore.SpeechSynthesizing] {
    get
    set
  }
  @_Concurrency.MainActor public init(speechSynthesizers: [any MapboxNavigationCore.SpeechSynthesizing])
  @_Concurrency.MainActor convenience public init(mapboxSpeechApiConfiguration: MapboxNavigationCore.ApiConfiguration, skuTokenProvider: @escaping @Sendable () -> Swift.String?, customSpeechSynthesizers: [any MapboxNavigationCore.SpeechSynthesizing] = [])
  @_Concurrency.MainActor final public func prepareIncomingSpokenInstructions(_ instructions: [MapboxNavigationCore.SpokenInstruction], locale: Foundation.Locale? = nil)
  @_Concurrency.MainActor final public func speak(_ instruction: MapboxNavigationCore.SpokenInstruction, during legProgress: MapboxNavigationCore.RouteLegProgress, locale: Foundation.Locale? = nil)
  @_Concurrency.MainActor final public func stopSpeaking()
  @_Concurrency.MainActor final public func interruptSpeaking()
  @objc deinit
}
@_Concurrency.MainActor final public class RouteVoiceController {
  @_Concurrency.MainActor final public var speechSynthesizer: any MapboxNavigationCore.SpeechSynthesizing {
    get
  }
  @_Concurrency.MainActor final public var playsRerouteSound: Swift.Bool
  @_Concurrency.MainActor public init(routeProgressing: Combine.AnyPublisher<MapboxNavigationCore.RouteProgressState?, Swift.Never>, rerouteStarted: Combine.AnyPublisher<Swift.Void, Swift.Never>, fasterRouteSet: Combine.AnyPublisher<Swift.Void, Swift.Never>, speechSynthesizer: any MapboxNavigationCore.SpeechSynthesizing)
  @objc deinit
}
public enum SpeechFailureAction : Swift.String, Swift.Sendable {
  case mix
  case duck
  case unduck
  case play
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SpeechError : Foundation.LocalizedError {
  case apiError(instruction: MapboxNavigationCore.SpokenInstruction, options: MapboxNavigationCore.SpeechOptions, underlying: (any Swift.Error)?)
  case noData(instruction: MapboxNavigationCore.SpokenInstruction, options: MapboxNavigationCore.SpeechOptions)
  case unableToControlAudio(instruction: MapboxNavigationCore.SpokenInstruction?, action: MapboxNavigationCore.SpeechFailureAction, underlying: (any Swift.Error)?)
  case unableToInitializePlayer(playerType: AVFAudio.AVAudioPlayer.Type, instruction: MapboxNavigationCore.SpokenInstruction, synthesizer: (any Swift.Sendable)?, underlying: any Swift.Error)
  case undefinedSpeechLocale(instruction: MapboxNavigationCore.SpokenInstruction)
  case unsupportedLocale(locale: Foundation.Locale)
}
public enum TextType : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable {
  case text
  case ssml
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AudioFormat : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable {
  case mp3
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SpeechGender : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable {
  case female
  case male
  case neuter
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct SpeechOptions : Swift.Codable, Swift.Sendable, Swift.Equatable {
  public init(text: Swift.String, locale: Foundation.Locale)
  public init(ssml: Swift.String, locale: Foundation.Locale)
  public var text: Swift.String
  public let textType: MapboxNavigationCore.TextType
  public var outputFormat: MapboxNavigationCore.AudioFormat
  public var locale: Foundation.Locale
  public var speechGender: MapboxNavigationCore.SpeechGender
  public static func == (a: MapboxNavigationCore.SpeechOptions, b: MapboxNavigationCore.SpeechOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_Concurrency.MainActor public protocol SpeechSynthesizing : AnyObject, Swift.Sendable {
  @_Concurrency.MainActor var voiceInstructions: Combine.AnyPublisher<any MapboxNavigationCore.VoiceInstructionEvent, Swift.Never> { get }
  @_Concurrency.MainActor var muted: Swift.Bool { get set }
  @_Concurrency.MainActor var volume: MapboxNavigationCore.VolumeMode { get set }
  @_Concurrency.MainActor var isSpeaking: Swift.Bool { get }
  @_Concurrency.MainActor var locale: Foundation.Locale? { get set }
  @_Concurrency.MainActor var managesAudioSession: Swift.Bool { get set }
  @_Concurrency.MainActor func prepareIncomingSpokenInstructions(_ instructions: [MapboxNavigationCore.SpokenInstruction], locale: Foundation.Locale?)
  @_Concurrency.MainActor func speak(_ instruction: MapboxNavigationCore.SpokenInstruction, during legProgress: MapboxNavigationCore.RouteLegProgress, locale: Foundation.Locale?)
  @_Concurrency.MainActor func stopSpeaking()
  @_Concurrency.MainActor func interruptSpeaking()
}
public protocol VoiceInstructionEvent {
}
public enum VoiceInstructionEvents {
  public struct WillSpeak : MapboxNavigationCore.VoiceInstructionEvent, Swift.Equatable {
    public let instruction: MapboxNavigationCore.SpokenInstruction
    public init(instruction: MapboxNavigationCore.SpokenInstruction)
    public static func == (a: MapboxNavigationCore.VoiceInstructionEvents.WillSpeak, b: MapboxNavigationCore.VoiceInstructionEvents.WillSpeak) -> Swift.Bool
  }
  public struct DidSpeak : MapboxNavigationCore.VoiceInstructionEvent, Swift.Equatable {
    public let instruction: MapboxNavigationCore.SpokenInstruction
    public init(instruction: MapboxNavigationCore.SpokenInstruction)
    public static func == (a: MapboxNavigationCore.VoiceInstructionEvents.DidSpeak, b: MapboxNavigationCore.VoiceInstructionEvents.DidSpeak) -> Swift.Bool
  }
  public struct DidInterrupt : MapboxNavigationCore.VoiceInstructionEvent, Swift.Equatable {
    public let interruptedInstruction: MapboxNavigationCore.SpokenInstruction
    public let interruptingInstruction: MapboxNavigationCore.SpokenInstruction
    public init(interruptedInstruction: MapboxNavigationCore.SpokenInstruction, interruptingInstruction: MapboxNavigationCore.SpokenInstruction)
    public static func == (a: MapboxNavigationCore.VoiceInstructionEvents.DidInterrupt, b: MapboxNavigationCore.VoiceInstructionEvents.DidInterrupt) -> Swift.Bool
  }
  public struct EncounteredError : MapboxNavigationCore.VoiceInstructionEvent {
    public let error: MapboxNavigationCore.SpeechError
    public init(error: MapboxNavigationCore.SpeechError)
  }
}
public enum VolumeMode : Swift.Equatable, Swift.Sendable {
  case system
  case override(Swift.Float)
  public static func == (a: MapboxNavigationCore.VolumeMode, b: MapboxNavigationCore.VolumeMode) -> Swift.Bool
}
extension MapboxNavigationCore.FeedbackSource : Swift.Equatable {}
extension MapboxNavigationCore.FeedbackSource : Swift.Hashable {}
extension MapboxNavigationCore.FeedbackSource : Swift.RawRepresentable {}
extension MapboxNavigationCore.PassiveNavigationFeedbackType : Swift.Equatable {}
extension MapboxNavigationCore.PassiveNavigationFeedbackType : Swift.Hashable {}
extension MapboxNavigationCore.SearchFeedbackType : Swift.Equatable {}
extension MapboxNavigationCore.SearchFeedbackType : Swift.Hashable {}
extension MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed : MapboxNavigationCore.NavigationHistoryEvent {}
extension MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed.Provider : Swift.Equatable {}
extension MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed.Provider : Swift.Hashable {}
extension MapboxNavigationCore.NavigationHistoryEvents.SearchResultUsed.Provider : Swift.RawRepresentable {}
extension MapboxNavigationCore.NavigationHistoryEvents.SearchResults : MapboxNavigationCore.NavigationHistoryEvent {}
extension MapboxNavigationCore.NavigationSession.SessionType : Swift.Equatable {}
extension MapboxNavigationCore.NavigationSession.SessionType : Swift.Hashable {}
extension MapboxNavigationCore.NavigationSession.SessionType : Swift.RawRepresentable {}
extension MapboxNavigationCore.NavigationSession.State : Swift.Equatable {}
extension MapboxNavigationCore.NavigationSession.State : Swift.Hashable {}
extension MapboxNavigationCore.NavigationSession.State : Swift.RawRepresentable {}
extension MapboxNavigationCore.NavigationCamera : Swift.Sendable {}
extension MapboxNavigationCore.NavigationCameraState : Swift.Hashable {}
extension MapboxNavigationCore.NavigationCameraStateTransition : Swift.Sendable {}
extension MapboxNavigationCore.NavigationCameraType : Swift.Equatable {}
extension MapboxNavigationCore.NavigationCameraType : Swift.Hashable {}
extension MapboxNavigationCore.CarPlayViewportDataSource : Swift.Sendable {}
extension MapboxNavigationCore.MobileViewportDataSource : Swift.Sendable {}
extension MapboxNavigationCore.RouteAnnotationKind : Swift.Equatable {}
extension MapboxNavigationCore.RouteAnnotationKind : Swift.Hashable {}
extension MapboxNavigationCore.OpenLROrientation : Swift.Hashable {}
extension MapboxNavigationCore.OpenLRSideOfRoad : Swift.Hashable {}
extension MapboxNavigationCore.RoadGraph.Edge.Directionality : Swift.Equatable {}
extension MapboxNavigationCore.RoadGraph.Edge.Directionality : Swift.Hashable {}
extension MapboxNavigationCore.ReroutingError : Swift.Equatable {}
extension MapboxNavigationCore.ReroutingError : Swift.Hashable {}
extension MapboxNavigationCore.Session.State.FreeDriveState : Swift.Equatable {}
extension MapboxNavigationCore.Session.State.FreeDriveState : Swift.Hashable {}
extension MapboxNavigationCore.Session.State.ActiveGuidanceState : Swift.Equatable {}
extension MapboxNavigationCore.Session.State.ActiveGuidanceState : Swift.Hashable {}
extension MapboxNavigationCore.RoutingProviderSource : Swift.Hashable {}
extension MapboxNavigationCore.UnitOfMeasurement : Swift.Hashable {}
extension MapboxNavigationCore.ApprovalMode : Swift.Hashable {}
extension MapboxNavigationCore.RouteVoiceController : Swift.Sendable {}
extension MapboxNavigationCore.SpeechFailureAction : Swift.Equatable {}
extension MapboxNavigationCore.SpeechFailureAction : Swift.Hashable {}
extension MapboxNavigationCore.SpeechFailureAction : Swift.RawRepresentable {}
extension MapboxNavigationCore.TextType : Swift.RawRepresentable {}
extension MapboxNavigationCore.AudioFormat : Swift.RawRepresentable {}
extension MapboxNavigationCore.SpeechGender : Swift.RawRepresentable {}
